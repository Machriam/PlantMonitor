//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { GatewayAppApiBase } from './GatewayAppApiBase';

export interface ITemperatureClient {

    getDevices(ip?: string | undefined): Promise<string[]>;

    getRunningMeasurements(): Promise<RunningMeasurement[]>;

    measurements(): Promise<TemperatureMeasurement[]>;

    addMeasurement(info: MeasurementStartInfo): Promise<void>;

    stopMeasurement(ip?: string | undefined): Promise<void>;
}

export class TemperatureClient extends GatewayAppApiBase implements ITemperatureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getDevices(ip?: string | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Temperature/devices?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDevices(_response));
        });
    }

    protected processGetDevices(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getRunningMeasurements(): Promise<RunningMeasurement[]> {
        let url_ = this.baseUrl + "/api/Temperature/runningmeasurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRunningMeasurements(_response));
        });
    }

    protected processGetRunningMeasurements(response: Response): Promise<RunningMeasurement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RunningMeasurement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RunningMeasurement[]>(null as any);
    }

    measurements(): Promise<TemperatureMeasurement[]> {
        let url_ = this.baseUrl + "/api/Temperature/measurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMeasurements(_response));
        });
    }

    protected processMeasurements(response: Response): Promise<TemperatureMeasurement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemperatureMeasurement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemperatureMeasurement[]>(null as any);
    }

    addMeasurement(info: MeasurementStartInfo): Promise<void> {
        let url_ = this.baseUrl + "/api/Temperature/addmeasurement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddMeasurement(_response));
        });
    }

    protected processAddMeasurement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    stopMeasurement(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Temperature/stopmeasurement?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStopMeasurement(_response));
        });
    }

    protected processStopMeasurement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IMovementProgrammingClient {

    getPlan(deviceId?: string | undefined): Promise<DeviceMovement>;

    updatePlan(movement: DeviceMovement): Promise<void>;
}

export class MovementProgrammingClient extends GatewayAppApiBase implements IMovementProgrammingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getPlan(deviceId?: string | undefined): Promise<DeviceMovement> {
        let url_ = this.baseUrl + "/api/MovementProgramming/getplan?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPlan(_response));
        });
    }

    protected processGetPlan(response: Response): Promise<DeviceMovement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceMovement.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceMovement>(null as any);
    }

    updatePlan(movement: DeviceMovement): Promise<void> {
        let url_ = this.baseUrl + "/api/MovementProgramming/updateplan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(movement);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdatePlan(_response));
        });
    }

    protected processUpdatePlan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPowerOutletClient {

    associateDeviceWithPowerOutlet(model: AssociatePowerOutletModel): Promise<void>;

    getOutlets(): Promise<OutletModel[]>;

    powerOutletForDevice(deviceId?: string | undefined): Promise<AssociatePowerOutletModel | null>;

    switchOutlet(ip?: string | undefined, codeId?: number | undefined): Promise<void>;
}

export class PowerOutletClient extends GatewayAppApiBase implements IPowerOutletClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    associateDeviceWithPowerOutlet(model: AssociatePowerOutletModel): Promise<void> {
        let url_ = this.baseUrl + "/api/PowerOutlet/updateassociatedoutlet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAssociateDeviceWithPowerOutlet(_response));
        });
    }

    protected processAssociateDeviceWithPowerOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOutlets(): Promise<OutletModel[]> {
        let url_ = this.baseUrl + "/api/PowerOutlet/outlets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetOutlets(_response));
        });
    }

    protected processGetOutlets(response: Response): Promise<OutletModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutletModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletModel[]>(null as any);
    }

    powerOutletForDevice(deviceId?: string | undefined): Promise<AssociatePowerOutletModel | null> {
        let url_ = this.baseUrl + "/api/PowerOutlet/getoutlet?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPowerOutletForDevice(_response));
        });
    }

    protected processPowerOutletForDevice(response: Response): Promise<AssociatePowerOutletModel | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociatePowerOutletModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociatePowerOutletModel | null>(null as any);
    }

    switchOutlet(ip?: string | undefined, codeId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PowerOutlet/switchoutlet?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (codeId === null)
            throw new Error("The parameter 'codeId' cannot be null.");
        else if (codeId !== undefined)
            url_ += "codeId=" + encodeURIComponent("" + codeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSwitchOutlet(_response));
        });
    }

    protected processSwitchOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IDeviceClient {

    previewImage(ip?: string | undefined, type?: CameraType | undefined): Promise<FileResponse>;

    killCamera(ip?: string | undefined, type?: CameraType | undefined): Promise<void>;

    runFFC(ip?: string | undefined): Promise<void>;

    calibrateExposure(ip?: string | undefined): Promise<void>;

    cameraInfo(ip?: string | undefined, type?: CameraType | undefined): Promise<string>;

    currentPosition(ip?: string | undefined): Promise<MotorPosition>;

    zeroPosition(ip?: string | undefined): Promise<void>;

    toggleMotorEngage(ip?: string | undefined, engage?: boolean | undefined): Promise<void>;

    move(ip?: string | undefined, steps?: number | undefined, minTime?: number | undefined, maxTime?: number | undefined, rampLength?: number | undefined): Promise<void>;
}

export class DeviceClient extends GatewayAppApiBase implements IDeviceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    previewImage(ip?: string | undefined, type?: CameraType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Device/previewimage?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPreviewImage(_response));
        });
    }

    protected processPreviewImage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    killCamera(ip?: string | undefined, type?: CameraType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/killcamera?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processKillCamera(_response));
        });
    }

    protected processKillCamera(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    runFFC(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/runffc?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRunFFC(_response));
        });
    }

    protected processRunFFC(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    calibrateExposure(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/calibrateexposure?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCalibrateExposure(_response));
        });
    }

    protected processCalibrateExposure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    cameraInfo(ip?: string | undefined, type?: CameraType | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Device/camerainfo?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCameraInfo(_response));
        });
    }

    protected processCameraInfo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    currentPosition(ip?: string | undefined): Promise<MotorPosition> {
        let url_ = this.baseUrl + "/api/Device/currentposition?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCurrentPosition(_response));
        });
    }

    protected processCurrentPosition(response: Response): Promise<MotorPosition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MotorPosition.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MotorPosition>(null as any);
    }

    zeroPosition(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/zeroposition?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processZeroPosition(_response));
        });
    }

    protected processZeroPosition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    toggleMotorEngage(ip?: string | undefined, engage?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/togglemotorengage?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (engage === null)
            throw new Error("The parameter 'engage' cannot be null.");
        else if (engage !== undefined)
            url_ += "engage=" + encodeURIComponent("" + engage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processToggleMotorEngage(_response));
        });
    }

    protected processToggleMotorEngage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    move(ip?: string | undefined, steps?: number | undefined, minTime?: number | undefined, maxTime?: number | undefined, rampLength?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/move?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (steps === null)
            throw new Error("The parameter 'steps' cannot be null.");
        else if (steps !== undefined)
            url_ += "steps=" + encodeURIComponent("" + steps) + "&";
        if (minTime === null)
            throw new Error("The parameter 'minTime' cannot be null.");
        else if (minTime !== undefined)
            url_ += "minTime=" + encodeURIComponent("" + minTime) + "&";
        if (maxTime === null)
            throw new Error("The parameter 'maxTime' cannot be null.");
        else if (maxTime !== undefined)
            url_ += "maxTime=" + encodeURIComponent("" + maxTime) + "&";
        if (rampLength === null)
            throw new Error("The parameter 'rampLength' cannot be null.");
        else if (rampLength !== undefined)
            url_ += "rampLength=" + encodeURIComponent("" + rampLength) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMove(_response));
        });
    }

    protected processMove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPictureClient {

    getAllPicturedDevices(): Promise<SeriesByDevice[]>;

    updateIrOffset(offset: IrCameraOffset, ip?: string | undefined): Promise<void>;

    getPictureSeries(deviceId?: string | undefined): Promise<PictureSeriesData[]>;
}

export class PictureClient extends GatewayAppApiBase implements IPictureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getAllPicturedDevices(): Promise<SeriesByDevice[]> {
        let url_ = this.baseUrl + "/api/Picture/allpictureddevices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllPicturedDevices(_response));
        });
    }

    protected processGetAllPicturedDevices(response: Response): Promise<SeriesByDevice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeriesByDevice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeriesByDevice[]>(null as any);
    }

    updateIrOffset(offset: IrCameraOffset, ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Picture/updateiroffset?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(offset);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateIrOffset(_response));
        });
    }

    protected processUpdateIrOffset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPictureSeries(deviceId?: string | undefined): Promise<PictureSeriesData[]> {
        let url_ = this.baseUrl + "/api/Picture/pictureseriesnames?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPictureSeries(_response));
        });
    }

    protected processGetPictureSeries(response: Response): Promise<PictureSeriesData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PictureSeriesData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureSeriesData[]>(null as any);
    }
}

export interface IDeviceConfigurationClient {

    getCertificateData(): Promise<CertificateData>;

    getWebSshCredentials(): Promise<WebSshCredentials>;

    getDeviceLog(ip?: string | undefined): Promise<string>;

    recheckDevice(ip?: string | undefined): Promise<DeviceHealth>;

    getDevices(): Promise<DeviceHealthState[]>;
}

export class DeviceConfigurationClient extends GatewayAppApiBase implements IDeviceConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getCertificateData(): Promise<CertificateData> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/certificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCertificateData(_response));
        });
    }

    protected processGetCertificateData(response: Response): Promise<CertificateData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateData>(null as any);
    }

    getWebSshCredentials(): Promise<WebSshCredentials> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/websshcredentials";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetWebSshCredentials(_response));
        });
    }

    protected processGetWebSshCredentials(response: Response): Promise<WebSshCredentials> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebSshCredentials.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebSshCredentials>(null as any);
    }

    getDeviceLog(ip?: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/devicelogs?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDeviceLog(_response));
        });
    }

    protected processGetDeviceLog(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    recheckDevice(ip?: string | undefined): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/recheckdevice?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRecheckDevice(_response));
        });
    }

    protected processRecheckDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceHealth.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    getDevices(): Promise<DeviceHealthState[]> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDevices(_response));
        });
    }

    protected processGetDevices(response: Response): Promise<DeviceHealthState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHealthState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealthState[]>(null as any);
    }
}

export interface IAutomaticPhotoTourClient {

    pausePhotoTour(id?: number | undefined, shouldBePaused?: boolean | undefined): Promise<void>;

    getEvents(photoTourId?: number | undefined): Promise<PhotoTourEvent[]>;

    getPhotoTours(): Promise<PhotoTourInfo[]>;

    startAutomaticTour(startInfo: AutomaticTourStartInfo): Promise<void>;
}

export class AutomaticPhotoTourClient extends GatewayAppApiBase implements IAutomaticPhotoTourClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    pausePhotoTour(id?: number | undefined, shouldBePaused?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/pausephototour?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (shouldBePaused === null)
            throw new Error("The parameter 'shouldBePaused' cannot be null.");
        else if (shouldBePaused !== undefined)
            url_ += "shouldBePaused=" + encodeURIComponent("" + shouldBePaused) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPausePhotoTour(_response));
        });
    }

    protected processPausePhotoTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getEvents(photoTourId?: number | undefined): Promise<PhotoTourEvent[]> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/events?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetEvents(_response));
        });
    }

    protected processGetEvents(response: Response): Promise<PhotoTourEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourEvent[]>(null as any);
    }

    getPhotoTours(): Promise<PhotoTourInfo[]> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/phototours";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPhotoTours(_response));
        });
    }

    protected processGetPhotoTours(response: Response): Promise<PhotoTourInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourInfo[]>(null as any);
    }

    startAutomaticTour(startInfo: AutomaticTourStartInfo): Promise<void> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/startphototour";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(startInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStartAutomaticTour(_response));
        });
    }

    protected processStartAutomaticTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IAppConfigurationClient {

    updateDeviceSettings(password?: string | undefined, user?: string | undefined): Promise<void>;

    updateIpRanges(ipFrom?: string | undefined, ipTo?: string | undefined): Promise<void>;
}

export class AppConfigurationClient extends GatewayAppApiBase implements IAppConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    updateDeviceSettings(password?: string | undefined, user?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AppConfiguration/updatedevicesettings?";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateDeviceSettings(_response));
        });
    }

    protected processUpdateDeviceSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateIpRanges(ipFrom?: string | undefined, ipTo?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AppConfiguration/updateipranges?";
        if (ipFrom === null)
            throw new Error("The parameter 'ipFrom' cannot be null.");
        else if (ipFrom !== undefined)
            url_ += "ipFrom=" + encodeURIComponent("" + ipFrom) + "&";
        if (ipTo === null)
            throw new Error("The parameter 'ipTo' cannot be null.");
        else if (ipTo !== undefined)
            url_ += "ipTo=" + encodeURIComponent("" + ipTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateIpRanges(_response));
        });
    }

    protected processUpdateIpRanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RunningMeasurement implements IRunningMeasurement {
    ip!: string;
    measurementId!: number;

    constructor(data?: IRunningMeasurement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ip = _data["Ip"];
            this.measurementId = _data["MeasurementId"];
        }
    }

    static fromJS(data: any): RunningMeasurement {
        data = typeof data === 'object' ? data : {};
        let result = new RunningMeasurement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Ip"] = this.ip;
        data["MeasurementId"] = this.measurementId;
        return data;
    }

    clone(): RunningMeasurement {
        const json = this.toJSON();
        let result = new RunningMeasurement();
        result.init(json);
        return result;
    }
}

export interface IRunningMeasurement {
    ip: string;
    measurementId: number;
}

export class TemperatureMeasurement implements ITemperatureMeasurement {
    id!: number;
    comment!: string;
    sensorId!: string;
    startTime!: Date;
    photoTourFk!: number | undefined;
    deviceId!: string;
    finished!: boolean;
    photoTourFkNavigation!: AutomaticPhotoTour | undefined;
    temperatureMeasurementValues!: TemperatureMeasurementValue[];

    constructor(data?: ITemperatureMeasurement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.comment = _data["Comment"];
            this.sensorId = _data["SensorId"];
            this.startTime = _data["StartTime"] ? new Date(_data["StartTime"].toString()) : <any>undefined;
            this.photoTourFk = _data["PhotoTourFk"];
            this.deviceId = _data["DeviceId"];
            this.finished = _data["Finished"];
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            if (Array.isArray(_data["TemperatureMeasurementValues"])) {
                this.temperatureMeasurementValues = [] as any;
                for (let item of _data["TemperatureMeasurementValues"])
                    this.temperatureMeasurementValues!.push(TemperatureMeasurementValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemperatureMeasurement {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Comment"] = this.comment;
        data["SensorId"] = this.sensorId;
        data["StartTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["PhotoTourFk"] = this.photoTourFk;
        data["DeviceId"] = this.deviceId;
        data["Finished"] = this.finished;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.temperatureMeasurementValues)) {
            data["TemperatureMeasurementValues"] = [];
            for (let item of this.temperatureMeasurementValues)
                data["TemperatureMeasurementValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): TemperatureMeasurement {
        const json = this.toJSON();
        let result = new TemperatureMeasurement();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurement {
    id: number;
    comment: string;
    sensorId: string;
    startTime: Date;
    photoTourFk: number | undefined;
    deviceId: string;
    finished: boolean;
    photoTourFkNavigation: AutomaticPhotoTour | undefined;
    temperatureMeasurementValues: TemperatureMeasurementValue[];
}

export class AutomaticPhotoTour implements IAutomaticPhotoTour {
    id!: number;
    deviceId!: string;
    name!: string;
    comment!: string;
    intervallInMinutes!: number;
    finished!: boolean;
    photoTourEvents!: PhotoTourEvent[];
    photoTourTrips!: PhotoTourTrip[];
    temperatureMeasurements!: TemperatureMeasurement[];

    constructor(data?: IAutomaticPhotoTour) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.deviceId = _data["DeviceId"];
            this.name = _data["Name"];
            this.comment = _data["Comment"];
            this.intervallInMinutes = _data["IntervallInMinutes"];
            this.finished = _data["Finished"];
            if (Array.isArray(_data["PhotoTourEvents"])) {
                this.photoTourEvents = [] as any;
                for (let item of _data["PhotoTourEvents"])
                    this.photoTourEvents!.push(PhotoTourEvent.fromJS(item));
            }
            if (Array.isArray(_data["PhotoTourTrips"])) {
                this.photoTourTrips = [] as any;
                for (let item of _data["PhotoTourTrips"])
                    this.photoTourTrips!.push(PhotoTourTrip.fromJS(item));
            }
            if (Array.isArray(_data["TemperatureMeasurements"])) {
                this.temperatureMeasurements = [] as any;
                for (let item of _data["TemperatureMeasurements"])
                    this.temperatureMeasurements!.push(TemperatureMeasurement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutomaticPhotoTour {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticPhotoTour();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DeviceId"] = this.deviceId;
        data["Name"] = this.name;
        data["Comment"] = this.comment;
        data["IntervallInMinutes"] = this.intervallInMinutes;
        data["Finished"] = this.finished;
        if (Array.isArray(this.photoTourEvents)) {
            data["PhotoTourEvents"] = [];
            for (let item of this.photoTourEvents)
                data["PhotoTourEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.photoTourTrips)) {
            data["PhotoTourTrips"] = [];
            for (let item of this.photoTourTrips)
                data["PhotoTourTrips"].push(item.toJSON());
        }
        if (Array.isArray(this.temperatureMeasurements)) {
            data["TemperatureMeasurements"] = [];
            for (let item of this.temperatureMeasurements)
                data["TemperatureMeasurements"].push(item.toJSON());
        }
        return data;
    }

    clone(): AutomaticPhotoTour {
        const json = this.toJSON();
        let result = new AutomaticPhotoTour();
        result.init(json);
        return result;
    }
}

export interface IAutomaticPhotoTour {
    id: number;
    deviceId: string;
    name: string;
    comment: string;
    intervallInMinutes: number;
    finished: boolean;
    photoTourEvents: PhotoTourEvent[];
    photoTourTrips: PhotoTourTrip[];
    temperatureMeasurements: TemperatureMeasurement[];
}

export class PhotoTourEvent implements IPhotoTourEvent {
    id!: number;
    photoTourFk!: number;
    message!: string;
    timestamp!: Date;
    referencesEvent!: number | undefined;
    inverseReferencesEventNavigation!: PhotoTourEvent[];
    photoTourFkNavigation!: AutomaticPhotoTour;
    referencesEventNavigation!: PhotoTourEvent | undefined;
    type!: PhotoTourEventType;

    constructor(data?: IPhotoTourEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTourFk = _data["PhotoTourFk"];
            this.message = _data["Message"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.referencesEvent = _data["ReferencesEvent"];
            if (Array.isArray(_data["InverseReferencesEventNavigation"])) {
                this.inverseReferencesEventNavigation = [] as any;
                for (let item of _data["InverseReferencesEventNavigation"])
                    this.inverseReferencesEventNavigation!.push(PhotoTourEvent.fromJS(item));
            }
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            this.referencesEventNavigation = _data["ReferencesEventNavigation"] ? PhotoTourEvent.fromJS(_data["ReferencesEventNavigation"]) : <any>undefined;
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): PhotoTourEvent {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTourFk"] = this.photoTourFk;
        data["Message"] = this.message;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["ReferencesEvent"] = this.referencesEvent;
        if (Array.isArray(this.inverseReferencesEventNavigation)) {
            data["InverseReferencesEventNavigation"] = [];
            for (let item of this.inverseReferencesEventNavigation)
                data["InverseReferencesEventNavigation"].push(item.toJSON());
        }
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        data["ReferencesEventNavigation"] = this.referencesEventNavigation ? this.referencesEventNavigation.toJSON() : <any>undefined;
        data["Type"] = this.type;
        return data;
    }

    clone(): PhotoTourEvent {
        const json = this.toJSON();
        let result = new PhotoTourEvent();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourEvent {
    id: number;
    photoTourFk: number;
    message: string;
    timestamp: Date;
    referencesEvent: number | undefined;
    inverseReferencesEventNavigation: PhotoTourEvent[];
    photoTourFkNavigation: AutomaticPhotoTour;
    referencesEventNavigation: PhotoTourEvent | undefined;
    type: PhotoTourEventType;
}

export enum PhotoTourEventType {
    Debug = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
}

export class PhotoTourTrip implements IPhotoTourTrip {
    id!: number;
    photoTourFk!: number;
    irDataFolder!: string;
    visDataFolder!: string;
    timestamp!: Date;
    photoTourFkNavigation!: AutomaticPhotoTour;

    constructor(data?: IPhotoTourTrip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTourFk = _data["PhotoTourFk"];
            this.irDataFolder = _data["IrDataFolder"];
            this.visDataFolder = _data["VisDataFolder"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoTourTrip {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourTrip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTourFk"] = this.photoTourFk;
        data["IrDataFolder"] = this.irDataFolder;
        data["VisDataFolder"] = this.visDataFolder;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        return data;
    }

    clone(): PhotoTourTrip {
        const json = this.toJSON();
        let result = new PhotoTourTrip();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourTrip {
    id: number;
    photoTourFk: number;
    irDataFolder: string;
    visDataFolder: string;
    timestamp: Date;
    photoTourFkNavigation: AutomaticPhotoTour;
}

export class TemperatureMeasurementValue implements ITemperatureMeasurementValue {
    id!: number;
    temperature!: number;
    timestamp!: Date;
    measurementFk!: number;
    measurementFkNavigation!: TemperatureMeasurement;

    constructor(data?: ITemperatureMeasurementValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.temperature = _data["Temperature"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.measurementFk = _data["MeasurementFk"];
            this.measurementFkNavigation = _data["MeasurementFkNavigation"] ? TemperatureMeasurement.fromJS(_data["MeasurementFkNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TemperatureMeasurementValue {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurementValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Temperature"] = this.temperature;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["MeasurementFk"] = this.measurementFk;
        data["MeasurementFkNavigation"] = this.measurementFkNavigation ? this.measurementFkNavigation.toJSON() : <any>undefined;
        return data;
    }

    clone(): TemperatureMeasurementValue {
        const json = this.toJSON();
        let result = new TemperatureMeasurementValue();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurementValue {
    id: number;
    temperature: number;
    timestamp: Date;
    measurementFk: number;
    measurementFkNavigation: TemperatureMeasurement;
}

export class MeasurementStartInfo implements IMeasurementStartInfo {
    devices!: MeasurementDevice[];
    ip!: string;

    constructor(data?: IMeasurementStartInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Devices"])) {
                this.devices = [] as any;
                for (let item of _data["Devices"])
                    this.devices!.push(MeasurementDevice.fromJS(item));
            }
            this.ip = _data["Ip"];
        }
    }

    static fromJS(data: any): MeasurementStartInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementStartInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devices)) {
            data["Devices"] = [];
            for (let item of this.devices)
                data["Devices"].push(item.toJSON());
        }
        data["Ip"] = this.ip;
        return data;
    }

    clone(): MeasurementStartInfo {
        const json = this.toJSON();
        let result = new MeasurementStartInfo();
        result.init(json);
        return result;
    }
}

export interface IMeasurementStartInfo {
    devices: MeasurementDevice[];
    ip: string;
}

export class MeasurementDevice implements IMeasurementDevice {
    sensorId!: string;
    comment!: string;

    constructor(data?: IMeasurementDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sensorId = _data["SensorId"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): MeasurementDevice {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SensorId"] = this.sensorId;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): MeasurementDevice {
        const json = this.toJSON();
        let result = new MeasurementDevice();
        result.init(json);
        return result;
    }
}

export interface IMeasurementDevice {
    sensorId: string;
    comment: string;
}

export class DeviceMovement implements IDeviceMovement {
    id!: number;
    deviceId!: string;
    movementPlanJson!: string;
    name!: string;
    movementPlan!: MovementPlan;

    constructor(data?: IDeviceMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.deviceId = _data["DeviceId"];
            this.movementPlanJson = _data["MovementPlanJson"];
            this.name = _data["Name"];
            this.movementPlan = _data["MovementPlan"] ? MovementPlan.fromJS(_data["MovementPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceMovement {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceMovement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DeviceId"] = this.deviceId;
        data["MovementPlanJson"] = this.movementPlanJson;
        data["Name"] = this.name;
        data["MovementPlan"] = this.movementPlan ? this.movementPlan.toJSON() : <any>undefined;
        return data;
    }

    clone(): DeviceMovement {
        const json = this.toJSON();
        let result = new DeviceMovement();
        result.init(json);
        return result;
    }
}

export interface IDeviceMovement {
    id: number;
    deviceId: string;
    movementPlanJson: string;
    name: string;
    movementPlan: MovementPlan;
}

export class MovementPlan implements IMovementPlan {
    stepPoints!: MovementPoint[];

    constructor(data?: IMovementPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["StepPoints"])) {
                this.stepPoints = [] as any;
                for (let item of _data["StepPoints"])
                    this.stepPoints!.push(MovementPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovementPlan {
        data = typeof data === 'object' ? data : {};
        let result = new MovementPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stepPoints)) {
            data["StepPoints"] = [];
            for (let item of this.stepPoints)
                data["StepPoints"].push(item.toJSON());
        }
        return data;
    }

    clone(): MovementPlan {
        const json = this.toJSON();
        let result = new MovementPlan();
        result.init(json);
        return result;
    }
}

export interface IMovementPlan {
    stepPoints: MovementPoint[];
}

export class MovementPoint implements IMovementPoint {
    stepOffset!: number;
    focusInCentimeter!: number;
    speed!: number;
    comment!: string;

    constructor(data?: IMovementPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepOffset = _data["StepOffset"];
            this.focusInCentimeter = _data["FocusInCentimeter"];
            this.speed = _data["Speed"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): MovementPoint {
        data = typeof data === 'object' ? data : {};
        let result = new MovementPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StepOffset"] = this.stepOffset;
        data["FocusInCentimeter"] = this.focusInCentimeter;
        data["Speed"] = this.speed;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): MovementPoint {
        const json = this.toJSON();
        let result = new MovementPoint();
        result.init(json);
        return result;
    }
}

export interface IMovementPoint {
    stepOffset: number;
    focusInCentimeter: number;
    speed: number;
    comment: string;
}

export class AssociatePowerOutletModel implements IAssociatePowerOutletModel {
    deviceId!: string;
    switchOnId!: number | undefined;
    switchOffId!: number | undefined;

    constructor(data?: IAssociatePowerOutletModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["DeviceId"];
            this.switchOnId = _data["SwitchOnId"];
            this.switchOffId = _data["SwitchOffId"];
        }
    }

    static fromJS(data: any): AssociatePowerOutletModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatePowerOutletModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeviceId"] = this.deviceId;
        data["SwitchOnId"] = this.switchOnId;
        data["SwitchOffId"] = this.switchOffId;
        return data;
    }

    clone(): AssociatePowerOutletModel {
        const json = this.toJSON();
        let result = new AssociatePowerOutletModel();
        result.init(json);
        return result;
    }
}

export interface IAssociatePowerOutletModel {
    deviceId: string;
    switchOnId: number | undefined;
    switchOffId: number | undefined;
}

export class OutletModel implements IOutletModel {
    switchOnId!: number;
    switchOffId!: number;
    name!: string;
    buttonNumber!: number;
    channel!: number;

    constructor(data?: IOutletModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchOnId = _data["SwitchOnId"];
            this.switchOffId = _data["SwitchOffId"];
            this.name = _data["Name"];
            this.buttonNumber = _data["ButtonNumber"];
            this.channel = _data["Channel"];
        }
    }

    static fromJS(data: any): OutletModel {
        data = typeof data === 'object' ? data : {};
        let result = new OutletModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SwitchOnId"] = this.switchOnId;
        data["SwitchOffId"] = this.switchOffId;
        data["Name"] = this.name;
        data["ButtonNumber"] = this.buttonNumber;
        data["Channel"] = this.channel;
        return data;
    }

    clone(): OutletModel {
        const json = this.toJSON();
        let result = new OutletModel();
        result.init(json);
        return result;
    }
}

export interface IOutletModel {
    switchOnId: number;
    switchOffId: number;
    name: string;
    buttonNumber: number;
    channel: number;
}

export enum CameraType {
    Vis = 0,
    IR = 1,
}

export class MotorPosition implements IMotorPosition {
    engaged!: boolean | undefined;
    position!: number | undefined;

    constructor(data?: IMotorPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.engaged = _data["engaged"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): MotorPosition {
        data = typeof data === 'object' ? data : {};
        let result = new MotorPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["engaged"] = this.engaged;
        data["position"] = this.position;
        return data;
    }

    clone(): MotorPosition {
        const json = this.toJSON();
        let result = new MotorPosition();
        result.init(json);
        return result;
    }
}

export interface IMotorPosition {
    engaged: boolean | undefined;
    position: number | undefined;
}

export class SeriesByDevice implements ISeriesByDevice {
    deviceId!: string;
    folderName!: string;

    constructor(data?: ISeriesByDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["DeviceId"];
            this.folderName = _data["FolderName"];
        }
    }

    static fromJS(data: any): SeriesByDevice {
        data = typeof data === 'object' ? data : {};
        let result = new SeriesByDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeviceId"] = this.deviceId;
        data["FolderName"] = this.folderName;
        return data;
    }

    clone(): SeriesByDevice {
        const json = this.toJSON();
        let result = new SeriesByDevice();
        result.init(json);
        return result;
    }
}

export interface ISeriesByDevice {
    deviceId: string;
    folderName: string;
}

export class IrCameraOffset implements IIrCameraOffset {
    left!: number | undefined;
    top!: number | undefined;

    constructor(data?: IIrCameraOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.left = _data["left"];
            this.top = _data["top"];
        }
    }

    static fromJS(data: any): IrCameraOffset {
        data = typeof data === 'object' ? data : {};
        let result = new IrCameraOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["left"] = this.left;
        data["top"] = this.top;
        return data;
    }

    clone(): IrCameraOffset {
        const json = this.toJSON();
        let result = new IrCameraOffset();
        result.init(json);
        return result;
    }
}

export interface IIrCameraOffset {
    left: number | undefined;
    top: number | undefined;
}

export class PictureSeriesData implements IPictureSeriesData {
    count!: number;
    folderName!: string;
    type!: CameraType | undefined;

    constructor(data?: IPictureSeriesData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["Count"];
            this.folderName = _data["FolderName"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): PictureSeriesData {
        data = typeof data === 'object' ? data : {};
        let result = new PictureSeriesData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Count"] = this.count;
        data["FolderName"] = this.folderName;
        data["Type"] = this.type;
        return data;
    }

    clone(): PictureSeriesData {
        const json = this.toJSON();
        let result = new PictureSeriesData();
        result.init(json);
        return result;
    }
}

export interface IPictureSeriesData {
    count: number;
    folderName: string;
    type: CameraType | undefined;
}

export class CertificateData implements ICertificateData {
    certificate!: string;
    key!: string;

    constructor(data?: ICertificateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificate = _data["Certificate"];
            this.key = _data["Key"];
        }
    }

    static fromJS(data: any): CertificateData {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Certificate"] = this.certificate;
        data["Key"] = this.key;
        return data;
    }

    clone(): CertificateData {
        const json = this.toJSON();
        let result = new CertificateData();
        result.init(json);
        return result;
    }
}

export interface ICertificateData {
    certificate: string;
    key: string;
}

export class WebSshCredentials implements IWebSshCredentials {
    protocol!: string;
    port!: string;
    password!: string;
    user!: string;

    constructor(data?: IWebSshCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocol = _data["Protocol"];
            this.port = _data["Port"];
            this.password = _data["Password"];
            this.user = _data["User"];
        }
    }

    static fromJS(data: any): WebSshCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new WebSshCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Protocol"] = this.protocol;
        data["Port"] = this.port;
        data["Password"] = this.password;
        data["User"] = this.user;
        return data;
    }

    clone(): WebSshCredentials {
        const json = this.toJSON();
        let result = new WebSshCredentials();
        result.init(json);
        return result;
    }
}

export interface IWebSshCredentials {
    protocol: string;
    port: string;
    password: string;
    user: string;
}

export class DeviceHealth implements IDeviceHealth {
    deviceName!: string | undefined;
    deviceId!: string | undefined;
    state!: HealthState | undefined;
    cameraOffset!: IrCameraOffset | undefined;

    constructor(data?: IDeviceHealth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"];
            this.deviceId = _data["deviceId"];
            this.state = _data["state"];
            this.cameraOffset = _data["cameraOffset"] ? IrCameraOffset.fromJS(_data["cameraOffset"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceHealth {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHealth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        data["state"] = this.state;
        data["cameraOffset"] = this.cameraOffset ? this.cameraOffset.toJSON() : <any>undefined;
        return data;
    }

    clone(): DeviceHealth {
        const json = this.toJSON();
        let result = new DeviceHealth();
        result.init(json);
        return result;
    }
}

export interface IDeviceHealth {
    deviceName: string | undefined;
    deviceId: string | undefined;
    state: HealthState | undefined;
    cameraOffset: IrCameraOffset | undefined;
}

export enum HealthState {
    NA = 0,
    NoirCameraFound = 1,
    ThermalCameraFound = 2,
    NoirCameraFunctional = 4,
    ThermalCameraFunctional = 8,
    HasTemperatureSensor = 16,
    CanSwitchOutlets = 32,
}

export class DeviceHealthState implements IDeviceHealthState {
    health!: DeviceHealth;
    retryTimes!: number;
    ip!: string;

    constructor(data?: IDeviceHealthState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.health = _data["Health"] ? DeviceHealth.fromJS(_data["Health"]) : <any>undefined;
            this.retryTimes = _data["RetryTimes"];
            this.ip = _data["Ip"];
        }
    }

    static fromJS(data: any): DeviceHealthState {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHealthState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Health"] = this.health ? this.health.toJSON() : <any>undefined;
        data["RetryTimes"] = this.retryTimes;
        data["Ip"] = this.ip;
        return data;
    }

    clone(): DeviceHealthState {
        const json = this.toJSON();
        let result = new DeviceHealthState();
        result.init(json);
        return result;
    }
}

export interface IDeviceHealthState {
    health: DeviceHealth;
    retryTimes: number;
    ip: string;
}

export class PhotoTourInfo implements IPhotoTourInfo {
    name!: string;
    finished!: boolean;
    id!: number;
    firstEvent!: Date;
    lastEvent!: Date;

    constructor(data?: IPhotoTourInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.finished = _data["Finished"];
            this.id = _data["Id"];
            this.firstEvent = _data["FirstEvent"] ? new Date(_data["FirstEvent"].toString()) : <any>undefined;
            this.lastEvent = _data["LastEvent"] ? new Date(_data["LastEvent"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoTourInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Finished"] = this.finished;
        data["Id"] = this.id;
        data["FirstEvent"] = this.firstEvent ? this.firstEvent.toISOString() : <any>undefined;
        data["LastEvent"] = this.lastEvent ? this.lastEvent.toISOString() : <any>undefined;
        return data;
    }

    clone(): PhotoTourInfo {
        const json = this.toJSON();
        let result = new PhotoTourInfo();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourInfo {
    name: string;
    finished: boolean;
    id: number;
    firstEvent: Date;
    lastEvent: Date;
}

export class AutomaticTourStartInfo implements IAutomaticTourStartInfo {
    intervallInMinutes!: number;
    movementPlan!: number;
    temperatureMeasureDevice!: TemperatureMeasurementInfo[];
    comment!: string;
    name!: string;
    deviceGuid!: string;

    constructor(data?: IAutomaticTourStartInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.intervallInMinutes = _data["IntervallInMinutes"];
            this.movementPlan = _data["MovementPlan"];
            if (Array.isArray(_data["TemperatureMeasureDevice"])) {
                this.temperatureMeasureDevice = [] as any;
                for (let item of _data["TemperatureMeasureDevice"])
                    this.temperatureMeasureDevice!.push(TemperatureMeasurementInfo.fromJS(item));
            }
            this.comment = _data["Comment"];
            this.name = _data["Name"];
            this.deviceGuid = _data["DeviceGuid"];
        }
    }

    static fromJS(data: any): AutomaticTourStartInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticTourStartInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IntervallInMinutes"] = this.intervallInMinutes;
        data["MovementPlan"] = this.movementPlan;
        if (Array.isArray(this.temperatureMeasureDevice)) {
            data["TemperatureMeasureDevice"] = [];
            for (let item of this.temperatureMeasureDevice)
                data["TemperatureMeasureDevice"].push(item.toJSON());
        }
        data["Comment"] = this.comment;
        data["Name"] = this.name;
        data["DeviceGuid"] = this.deviceGuid;
        return data;
    }

    clone(): AutomaticTourStartInfo {
        const json = this.toJSON();
        let result = new AutomaticTourStartInfo();
        result.init(json);
        return result;
    }
}

export interface IAutomaticTourStartInfo {
    intervallInMinutes: number;
    movementPlan: number;
    temperatureMeasureDevice: TemperatureMeasurementInfo[];
    comment: string;
    name: string;
    deviceGuid: string;
}

export class TemperatureMeasurementInfo implements ITemperatureMeasurementInfo {
    guid!: string;
    comment!: string;

    constructor(data?: ITemperatureMeasurementInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["Guid"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): TemperatureMeasurementInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurementInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): TemperatureMeasurementInfo {
        const json = this.toJSON();
        let result = new TemperatureMeasurementInfo();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurementInfo {
    guid: string;
    comment: string;
}

export class StreamingMetaData implements IStreamingMetaData {
    resolutionDivider!: number;
    quality!: number;
    distanceInM!: number;
    storeData!: boolean;
    positionsToStream!: number[];
    type!: string;

    constructor(data?: IStreamingMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resolutionDivider = _data["ResolutionDivider"];
            this.quality = _data["Quality"];
            this.distanceInM = _data["DistanceInM"];
            this.storeData = _data["StoreData"];
            if (Array.isArray(_data["PositionsToStream"])) {
                this.positionsToStream = [] as any;
                for (let item of _data["PositionsToStream"])
                    this.positionsToStream!.push(item);
            }
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): StreamingMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new StreamingMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResolutionDivider"] = this.resolutionDivider;
        data["Quality"] = this.quality;
        data["DistanceInM"] = this.distanceInM;
        data["StoreData"] = this.storeData;
        if (Array.isArray(this.positionsToStream)) {
            data["PositionsToStream"] = [];
            for (let item of this.positionsToStream)
                data["PositionsToStream"].push(item);
        }
        data["Type"] = this.type;
        return data;
    }

    clone(): StreamingMetaData {
        const json = this.toJSON();
        let result = new StreamingMetaData();
        result.init(json);
        return result;
    }
}

export interface IStreamingMetaData {
    resolutionDivider: number;
    quality: number;
    distanceInM: number;
    storeData: boolean;
    positionsToStream: number[];
    type: string;
}

export class TemperatureStreamData implements ITemperatureStreamData {
    temperatureInC!: number;
    device!: string;
    time!: Date;

    constructor(data?: ITemperatureStreamData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperatureInC = _data["TemperatureInC"];
            this.device = _data["Device"];
            this.time = _data["Time"] ? new Date(_data["Time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TemperatureStreamData {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureStreamData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TemperatureInC"] = this.temperatureInC;
        data["Device"] = this.device;
        data["Time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }

    clone(): TemperatureStreamData {
        const json = this.toJSON();
        let result = new TemperatureStreamData();
        result.init(json);
        return result;
    }
}

export interface ITemperatureStreamData {
    temperatureInC: number;
    device: string;
    time: Date;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable @typescript-eslint/no-unused-vars */