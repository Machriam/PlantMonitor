//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { GatewayAppApiBase } from './GatewayAppApiBase';

export interface ITemperatureClient {

    getDevices(ip?: string | undefined): Promise<string[]>;

    getRunningMeasurements(): Promise<RunningMeasurement[]>;

    measurements(): Promise<TemperatureMeasurement[]>;

    temperaturesOfMeasurement(measurementId?: number | undefined): Promise<MeasurementTemperatureDatum[]>;

    addMeasurement(info: MeasurementStartInfo): Promise<void>;

    stopMeasurement(ip?: string | undefined): Promise<void>;
}

export class TemperatureClient extends GatewayAppApiBase implements ITemperatureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getDevices(ip?: string | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Temperature/devices?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDevices(_response));
        });
    }

    protected processGetDevices(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getRunningMeasurements(): Promise<RunningMeasurement[]> {
        let url_ = this.baseUrl + "/api/Temperature/runningmeasurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRunningMeasurements(_response));
        });
    }

    protected processGetRunningMeasurements(response: Response): Promise<RunningMeasurement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RunningMeasurement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RunningMeasurement[]>(null as any);
    }

    measurements(): Promise<TemperatureMeasurement[]> {
        let url_ = this.baseUrl + "/api/Temperature/measurements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMeasurements(_response));
        });
    }

    protected processMeasurements(response: Response): Promise<TemperatureMeasurement[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemperatureMeasurement.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemperatureMeasurement[]>(null as any);
    }

    temperaturesOfMeasurement(measurementId?: number | undefined): Promise<MeasurementTemperatureDatum[]> {
        let url_ = this.baseUrl + "/api/Temperature/temperatureofmeasurement?";
        if (measurementId === null)
            throw new Error("The parameter 'measurementId' cannot be null.");
        else if (measurementId !== undefined)
            url_ += "measurementId=" + encodeURIComponent("" + measurementId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemperaturesOfMeasurement(_response));
        });
    }

    protected processTemperaturesOfMeasurement(response: Response): Promise<MeasurementTemperatureDatum[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MeasurementTemperatureDatum.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MeasurementTemperatureDatum[]>(null as any);
    }

    addMeasurement(info: MeasurementStartInfo): Promise<void> {
        let url_ = this.baseUrl + "/api/Temperature/addmeasurement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddMeasurement(_response));
        });
    }

    protected processAddMeasurement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    stopMeasurement(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Temperature/stopmeasurement?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStopMeasurement(_response));
        });
    }

    protected processStopMeasurement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPhotoStitchingClient {

    plantsForTour(tourId?: number | undefined): Promise<PhotoTourPlantInfo[]>;

    extractionsOfTrip(tripId?: number | undefined): Promise<PlantExtractionTemplateModel[]>;

    tripsOfTour(tourId?: number | undefined): Promise<PhotoTourTrip[]>;

    removePlantsFromTour(plantIds: number[]): Promise<void>;

    croppedImageFor(extractionTemplateId?: number | undefined, photoTripId?: number | undefined, xOffset?: number | undefined, yOffset?: number | undefined): Promise<ImageCropPreview | null>;

    updateIrOffset(adjustment: IrOffsetFineAdjustment): Promise<void>;

    associatePlantImageSection(section: PlantImageSection): Promise<void>;

    removePlantImageSections(sectionIds: number[]): Promise<void>;

    recalculatePhotoTour(photoTourFk?: number | undefined): Promise<void>;

    addPlantsToTour(plants: AddPlantModel): Promise<void>;
}

export class PhotoStitchingClient extends GatewayAppApiBase implements IPhotoStitchingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    plantsForTour(tourId?: number | undefined): Promise<PhotoTourPlantInfo[]> {
        let url_ = this.baseUrl + "/api/PhotoStitching/plantsfortour?";
        if (tourId === null)
            throw new Error("The parameter 'tourId' cannot be null.");
        else if (tourId !== undefined)
            url_ += "tourId=" + encodeURIComponent("" + tourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPlantsForTour(_response));
        });
    }

    protected processPlantsForTour(response: Response): Promise<PhotoTourPlantInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourPlantInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourPlantInfo[]>(null as any);
    }

    extractionsOfTrip(tripId?: number | undefined): Promise<PlantExtractionTemplateModel[]> {
        let url_ = this.baseUrl + "/api/PhotoStitching/extractionsoftrip?";
        if (tripId === null)
            throw new Error("The parameter 'tripId' cannot be null.");
        else if (tripId !== undefined)
            url_ += "tripId=" + encodeURIComponent("" + tripId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processExtractionsOfTrip(_response));
        });
    }

    protected processExtractionsOfTrip(response: Response): Promise<PlantExtractionTemplateModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlantExtractionTemplateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlantExtractionTemplateModel[]>(null as any);
    }

    tripsOfTour(tourId?: number | undefined): Promise<PhotoTourTrip[]> {
        let url_ = this.baseUrl + "/api/PhotoStitching/tripsoftour?";
        if (tourId === null)
            throw new Error("The parameter 'tourId' cannot be null.");
        else if (tourId !== undefined)
            url_ += "tourId=" + encodeURIComponent("" + tourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTripsOfTour(_response));
        });
    }

    protected processTripsOfTour(response: Response): Promise<PhotoTourTrip[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourTrip.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourTrip[]>(null as any);
    }

    removePlantsFromTour(plantIds: number[]): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/removeplants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(plantIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRemovePlantsFromTour(_response));
        });
    }

    protected processRemovePlantsFromTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    croppedImageFor(extractionTemplateId?: number | undefined, photoTripId?: number | undefined, xOffset?: number | undefined, yOffset?: number | undefined): Promise<ImageCropPreview | null> {
        let url_ = this.baseUrl + "/api/PhotoStitching/croppedimagefor?";
        if (extractionTemplateId === null)
            throw new Error("The parameter 'extractionTemplateId' cannot be null.");
        else if (extractionTemplateId !== undefined)
            url_ += "extractionTemplateId=" + encodeURIComponent("" + extractionTemplateId) + "&";
        if (photoTripId === null)
            throw new Error("The parameter 'photoTripId' cannot be null.");
        else if (photoTripId !== undefined)
            url_ += "photoTripId=" + encodeURIComponent("" + photoTripId) + "&";
        if (xOffset === null)
            throw new Error("The parameter 'xOffset' cannot be null.");
        else if (xOffset !== undefined)
            url_ += "xOffset=" + encodeURIComponent("" + xOffset) + "&";
        if (yOffset === null)
            throw new Error("The parameter 'yOffset' cannot be null.");
        else if (yOffset !== undefined)
            url_ += "yOffset=" + encodeURIComponent("" + yOffset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCroppedImageFor(_response));
        });
    }

    protected processCroppedImageFor(response: Response): Promise<ImageCropPreview | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImageCropPreview.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImageCropPreview | null>(null as any);
    }

    updateIrOffset(adjustment: IrOffsetFineAdjustment): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/updateiroffset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(adjustment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateIrOffset(_response));
        });
    }

    protected processUpdateIrOffset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    associatePlantImageSection(section: PlantImageSection): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/associateplantimagesection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(section);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAssociatePlantImageSection(_response));
        });
    }

    protected processAssociatePlantImageSection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    removePlantImageSections(sectionIds: number[]): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/removeplantimagesection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sectionIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRemovePlantImageSections(_response));
        });
    }

    protected processRemovePlantImageSections(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    recalculatePhotoTour(photoTourFk?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/recalculatephototour?";
        if (photoTourFk === null)
            throw new Error("The parameter 'photoTourFk' cannot be null.");
        else if (photoTourFk !== undefined)
            url_ += "photoTourFk=" + encodeURIComponent("" + photoTourFk) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRecalculatePhotoTour(_response));
        });
    }

    protected processRecalculatePhotoTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    addPlantsToTour(plants: AddPlantModel): Promise<void> {
        let url_ = this.baseUrl + "/api/PhotoStitching/addplantstotour";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(plants);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddPlantsToTour(_response));
        });
    }

    protected processAddPlantsToTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPictureClient {

    getAllPicturedDevices(): Promise<SeriesByDevice[]>;

    updateIrOffset(offset: IrCameraOffset, ip?: string | undefined): Promise<void>;

    getPictureSeries(deviceId?: string | undefined): Promise<PictureSeriesData[]>;

    pictureSeriesOfTour(photoTour?: number | undefined): Promise<PictureTripData[]>;
}

export class PictureClient extends GatewayAppApiBase implements IPictureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getAllPicturedDevices(): Promise<SeriesByDevice[]> {
        let url_ = this.baseUrl + "/api/Picture/allpictureddevices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllPicturedDevices(_response));
        });
    }

    protected processGetAllPicturedDevices(response: Response): Promise<SeriesByDevice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeriesByDevice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeriesByDevice[]>(null as any);
    }

    updateIrOffset(offset: IrCameraOffset, ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Picture/updateiroffset?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(offset);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateIrOffset(_response));
        });
    }

    protected processUpdateIrOffset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getPictureSeries(deviceId?: string | undefined): Promise<PictureSeriesData[]> {
        let url_ = this.baseUrl + "/api/Picture/pictureseriesnames?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPictureSeries(_response));
        });
    }

    protected processGetPictureSeries(response: Response): Promise<PictureSeriesData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PictureSeriesData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureSeriesData[]>(null as any);
    }

    pictureSeriesOfTour(photoTour?: number | undefined): Promise<PictureTripData[]> {
        let url_ = this.baseUrl + "/api/Picture/pictureseriesoftour?";
        if (photoTour === null)
            throw new Error("The parameter 'photoTour' cannot be null.");
        else if (photoTour !== undefined)
            url_ += "photoTour=" + encodeURIComponent("" + photoTour) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPictureSeriesOfTour(_response));
        });
    }

    protected processPictureSeriesOfTour(response: Response): Promise<PictureTripData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PictureTripData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureTripData[]>(null as any);
    }
}

export interface IMovementProgrammingClient {

    getPlan(deviceId?: string | undefined): Promise<DeviceMovement>;

    updatePlan(movement: DeviceMovement): Promise<void>;
}

export class MovementProgrammingClient extends GatewayAppApiBase implements IMovementProgrammingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getPlan(deviceId?: string | undefined): Promise<DeviceMovement> {
        let url_ = this.baseUrl + "/api/MovementProgramming/getplan?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPlan(_response));
        });
    }

    protected processGetPlan(response: Response): Promise<DeviceMovement> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceMovement.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceMovement>(null as any);
    }

    updatePlan(movement: DeviceMovement): Promise<void> {
        let url_ = this.baseUrl + "/api/MovementProgramming/updateplan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(movement);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdatePlan(_response));
        });
    }

    protected processUpdatePlan(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IPowerOutletClient {

    associateDeviceWithPowerOutlet(model: AssociatePowerOutletModel): Promise<void>;

    getOutlets(): Promise<OutletModel[]>;

    powerOutletForDevice(deviceId?: string | undefined): Promise<AssociatePowerOutletModel | null>;

    switchOutlet(ip?: string | undefined, codeId?: number | undefined): Promise<void>;
}

export class PowerOutletClient extends GatewayAppApiBase implements IPowerOutletClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    associateDeviceWithPowerOutlet(model: AssociatePowerOutletModel): Promise<void> {
        let url_ = this.baseUrl + "/api/PowerOutlet/updateassociatedoutlet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAssociateDeviceWithPowerOutlet(_response));
        });
    }

    protected processAssociateDeviceWithPowerOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getOutlets(): Promise<OutletModel[]> {
        let url_ = this.baseUrl + "/api/PowerOutlet/outlets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetOutlets(_response));
        });
    }

    protected processGetOutlets(response: Response): Promise<OutletModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutletModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutletModel[]>(null as any);
    }

    powerOutletForDevice(deviceId?: string | undefined): Promise<AssociatePowerOutletModel | null> {
        let url_ = this.baseUrl + "/api/PowerOutlet/getoutlet?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPowerOutletForDevice(_response));
        });
    }

    protected processPowerOutletForDevice(response: Response): Promise<AssociatePowerOutletModel | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociatePowerOutletModel.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssociatePowerOutletModel | null>(null as any);
    }

    switchOutlet(ip?: string | undefined, codeId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PowerOutlet/switchoutlet?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (codeId === null)
            throw new Error("The parameter 'codeId' cannot be null.");
        else if (codeId !== undefined)
            url_ += "codeId=" + encodeURIComponent("" + codeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSwitchOutlet(_response));
        });
    }

    protected processSwitchOutlet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IDeviceClient {

    previewImage(ip?: string | undefined, type?: CameraType | undefined): Promise<FileResponse>;

    killCamera(ip?: string | undefined, type?: CameraType | undefined): Promise<void>;

    runFFC(ip?: string | undefined): Promise<void>;

    calibrateExposure(ip?: string | undefined): Promise<void>;

    cameraInfo(ip?: string | undefined, type?: CameraType | undefined): Promise<string>;

    currentPosition(ip?: string | undefined): Promise<MotorPosition>;

    zeroPosition(ip?: string | undefined): Promise<void>;

    toggleMotorEngage(ip?: string | undefined, engage?: boolean | undefined): Promise<void>;

    move(ip?: string | undefined, steps?: number | undefined, minTime?: number | undefined, maxTime?: number | undefined, rampLength?: number | undefined): Promise<void>;
}

export class DeviceClient extends GatewayAppApiBase implements IDeviceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    previewImage(ip?: string | undefined, type?: CameraType | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Device/previewimage?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPreviewImage(_response));
        });
    }

    protected processPreviewImage(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    killCamera(ip?: string | undefined, type?: CameraType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/killcamera?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processKillCamera(_response));
        });
    }

    protected processKillCamera(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    runFFC(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/runffc?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRunFFC(_response));
        });
    }

    protected processRunFFC(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    calibrateExposure(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/calibrateexposure?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCalibrateExposure(_response));
        });
    }

    protected processCalibrateExposure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    cameraInfo(ip?: string | undefined, type?: CameraType | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Device/camerainfo?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCameraInfo(_response));
        });
    }

    protected processCameraInfo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    currentPosition(ip?: string | undefined): Promise<MotorPosition> {
        let url_ = this.baseUrl + "/api/Device/currentposition?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCurrentPosition(_response));
        });
    }

    protected processCurrentPosition(response: Response): Promise<MotorPosition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MotorPosition.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MotorPosition>(null as any);
    }

    zeroPosition(ip?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/zeroposition?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processZeroPosition(_response));
        });
    }

    protected processZeroPosition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    toggleMotorEngage(ip?: string | undefined, engage?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/togglemotorengage?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (engage === null)
            throw new Error("The parameter 'engage' cannot be null.");
        else if (engage !== undefined)
            url_ += "engage=" + encodeURIComponent("" + engage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processToggleMotorEngage(_response));
        });
    }

    protected processToggleMotorEngage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    move(ip?: string | undefined, steps?: number | undefined, minTime?: number | undefined, maxTime?: number | undefined, rampLength?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Device/move?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (steps === null)
            throw new Error("The parameter 'steps' cannot be null.");
        else if (steps !== undefined)
            url_ += "steps=" + encodeURIComponent("" + steps) + "&";
        if (minTime === null)
            throw new Error("The parameter 'minTime' cannot be null.");
        else if (minTime !== undefined)
            url_ += "minTime=" + encodeURIComponent("" + minTime) + "&";
        if (maxTime === null)
            throw new Error("The parameter 'maxTime' cannot be null.");
        else if (maxTime !== undefined)
            url_ += "maxTime=" + encodeURIComponent("" + maxTime) + "&";
        if (rampLength === null)
            throw new Error("The parameter 'rampLength' cannot be null.");
        else if (rampLength !== undefined)
            url_ += "rampLength=" + encodeURIComponent("" + rampLength) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMove(_response));
        });
    }

    protected processMove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IDeviceConfigurationClient {

    getCertificateData(): Promise<CertificateData>;

    getWebSshCredentials(): Promise<WebSshCredentials>;

    getDeviceLog(ip?: string | undefined): Promise<string>;

    getAllDeviceLog(ip?: string | undefined): Promise<string>;

    recheckDevice(ip?: string | undefined): Promise<DeviceHealth>;

    getDevices(): Promise<DeviceHealthState[]>;
}

export class DeviceConfigurationClient extends GatewayAppApiBase implements IDeviceConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getCertificateData(): Promise<CertificateData> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/certificates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCertificateData(_response));
        });
    }

    protected processGetCertificateData(response: Response): Promise<CertificateData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateData>(null as any);
    }

    getWebSshCredentials(): Promise<WebSshCredentials> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/websshcredentials";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetWebSshCredentials(_response));
        });
    }

    protected processGetWebSshCredentials(response: Response): Promise<WebSshCredentials> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebSshCredentials.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebSshCredentials>(null as any);
    }

    getDeviceLog(ip?: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/devicelogs?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDeviceLog(_response));
        });
    }

    protected processGetDeviceLog(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getAllDeviceLog(ip?: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/alldevicelogs?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllDeviceLog(_response));
        });
    }

    protected processGetAllDeviceLog(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    recheckDevice(ip?: string | undefined): Promise<DeviceHealth> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/recheckdevice?";
        if (ip === null)
            throw new Error("The parameter 'ip' cannot be null.");
        else if (ip !== undefined)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRecheckDevice(_response));
        });
    }

    protected processRecheckDevice(response: Response): Promise<DeviceHealth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceHealth.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealth>(null as any);
    }

    getDevices(): Promise<DeviceHealthState[]> {
        let url_ = this.baseUrl + "/api/DeviceConfiguration/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDevices(_response));
        });
    }

    protected processGetDevices(response: Response): Promise<DeviceHealthState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHealthState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceHealthState[]>(null as any);
    }
}

export interface IDashboardClient {

    virtualImageList(photoTourId?: number | undefined): Promise<VirtualImageInfo[]>;

    summaryForTour(photoTourId?: number | undefined): Promise<VirtualImageSummary[]>;

    createPhotoSummaryExport(photoTourId?: number | undefined): Promise<string>;

    temperatureSummary(photoTourId?: number | undefined): Promise<TemperatureSummaryData[]>;

    virtualImage(name?: string | undefined, photoTourId?: number | undefined): Promise<string | null>;

    plantMaskParameterFor(virtualImageTime?: Date | null | undefined, photoTourId?: number | null | undefined): Promise<SegmentationTemplate>;

    storeCustomSegmentation(parameter: SegmentationTemplate, virtualImageTime?: Date | undefined, photoTourId?: number | undefined): Promise<void>;

    segmentedImage(name?: string | undefined, photoTourId?: number | undefined, parameter?: SegmentationTemplate | undefined): Promise<string>;

    statusOfDownloadTourData(): Promise<DownloadInfo[]>;

    deleteTourData(photoTourId?: number | undefined): Promise<void>;

    requestDownloadTourData(photoTourId?: number | undefined): Promise<DownloadInfo>;
}

export class DashboardClient extends GatewayAppApiBase implements IDashboardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    virtualImageList(photoTourId?: number | undefined): Promise<VirtualImageInfo[]> {
        let url_ = this.baseUrl + "/api/Dashboard/virtualimagelist?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVirtualImageList(_response));
        });
    }

    protected processVirtualImageList(response: Response): Promise<VirtualImageInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VirtualImageInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VirtualImageInfo[]>(null as any);
    }

    summaryForTour(photoTourId?: number | undefined): Promise<VirtualImageSummary[]> {
        let url_ = this.baseUrl + "/api/Dashboard/fullsummaryinformation?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSummaryForTour(_response));
        });
    }

    protected processSummaryForTour(response: Response): Promise<VirtualImageSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VirtualImageSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VirtualImageSummary[]>(null as any);
    }

    createPhotoSummaryExport(photoTourId?: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Dashboard/summaryexport?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreatePhotoSummaryExport(_response));
        });
    }

    protected processCreatePhotoSummaryExport(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    temperatureSummary(photoTourId?: number | undefined): Promise<TemperatureSummaryData[]> {
        let url_ = this.baseUrl + "/api/Dashboard/temperaturedata?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemperatureSummary(_response));
        });
    }

    protected processTemperatureSummary(response: Response): Promise<TemperatureSummaryData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemperatureSummaryData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemperatureSummaryData[]>(null as any);
    }

    virtualImage(name?: string | undefined, photoTourId?: number | undefined): Promise<string | null> {
        let url_ = this.baseUrl + "/api/Dashboard/virtualimage?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processVirtualImage(_response));
        });
    }

    protected processVirtualImage(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(null as any);
    }

    plantMaskParameterFor(virtualImageTime?: Date | null | undefined, photoTourId?: number | null | undefined): Promise<SegmentationTemplate> {
        let url_ = this.baseUrl + "/api/Dashboard/plantmaskparameter?";
        if (virtualImageTime !== undefined && virtualImageTime !== null)
            url_ += "virtualImageTime=" + encodeURIComponent(virtualImageTime ? "" + virtualImageTime.toISOString() : "") + "&";
        if (photoTourId !== undefined && photoTourId !== null)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPlantMaskParameterFor(_response));
        });
    }

    protected processPlantMaskParameterFor(response: Response): Promise<SegmentationTemplate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SegmentationTemplate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SegmentationTemplate>(null as any);
    }

    storeCustomSegmentation(parameter: SegmentationTemplate, virtualImageTime?: Date | undefined, photoTourId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Dashboard/storecustomsegmentation?";
        if (virtualImageTime === null)
            throw new Error("The parameter 'virtualImageTime' cannot be null.");
        else if (virtualImageTime !== undefined)
            url_ += "virtualImageTime=" + encodeURIComponent(virtualImageTime ? "" + virtualImageTime.toISOString() : "") + "&";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameter);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStoreCustomSegmentation(_response));
        });
    }

    protected processStoreCustomSegmentation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    segmentedImage(name?: string | undefined, photoTourId?: number | undefined, parameter?: SegmentationTemplate | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Dashboard/segmentedimage?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameter);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSegmentedImage(_response));
        });
    }

    protected processSegmentedImage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    statusOfDownloadTourData(): Promise<DownloadInfo[]> {
        let url_ = this.baseUrl + "/api/Dashboard/statusofdownloadtourdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStatusOfDownloadTourData(_response));
        });
    }

    protected processStatusOfDownloadTourData(response: Response): Promise<DownloadInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DownloadInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DownloadInfo[]>(null as any);
    }

    deleteTourData(photoTourId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Dashboard/deletetourdata?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteTourData(_response));
        });
    }

    protected processDeleteTourData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    requestDownloadTourData(photoTourId?: number | undefined): Promise<DownloadInfo> {
        let url_ = this.baseUrl + "/api/Dashboard/requestdownloadtourdata?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRequestDownloadTourData(_response));
        });
    }

    protected processRequestDownloadTourData(response: Response): Promise<DownloadInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DownloadInfo>(null as any);
    }
}

export interface ICustomTourCreationClient {

    uploadFile(name?: string | null | undefined, comment?: string | null | undefined, pixelSizeInMm?: string | null | undefined, file?: FileParameter | null | undefined, progressGuid?: string | null | undefined): Promise<void>;

    getUploadProgress(progressGuid?: string | undefined): Promise<UploadProgress | null>;
}

export class CustomTourCreationClient extends GatewayAppApiBase implements ICustomTourCreationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    uploadFile(name?: string | null | undefined, comment?: string | null | undefined, pixelSizeInMm?: string | null | undefined, file?: FileParameter | null | undefined, progressGuid?: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/CustomTourCreation/uploadcustomtour";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (comment !== null && comment !== undefined)
            content_.append("Comment", comment.toString());
        if (pixelSizeInMm !== null && pixelSizeInMm !== undefined)
            content_.append("PixelSizeInMm", pixelSizeInMm.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (progressGuid !== null && progressGuid !== undefined)
            content_.append("ProgressGuid", progressGuid.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUploadFile(_response));
        });
    }

    protected processUploadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getUploadProgress(progressGuid?: string | undefined): Promise<UploadProgress | null> {
        let url_ = this.baseUrl + "/api/CustomTourCreation/uploadprogress?";
        if (progressGuid === null)
            throw new Error("The parameter 'progressGuid' cannot be null.");
        else if (progressGuid !== undefined)
            url_ += "progressGuid=" + encodeURIComponent("" + progressGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUploadProgress(_response));
        });
    }

    protected processGetUploadProgress(response: Response): Promise<UploadProgress | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadProgress.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadProgress | null>(null as any);
    }
}

export interface IAutomaticPhotoTourClient {

    updatePhotoTour(id?: number | undefined, newIntervallInMinutes?: number | undefined, pixelSizeInMm?: number | undefined): Promise<void>;

    pausePhotoTour(id?: number | undefined, shouldBePaused?: boolean | undefined): Promise<void>;

    getEvents(photoTourId?: number | undefined, allLogs?: boolean | undefined): Promise<PhotoTourEvent[]>;

    getPhotoTours(): Promise<PhotoTourInfo[]>;

    startAutomaticTour(startInfo: AutomaticTourStartInfo): Promise<void>;
}

export class AutomaticPhotoTourClient extends GatewayAppApiBase implements IAutomaticPhotoTourClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    updatePhotoTour(id?: number | undefined, newIntervallInMinutes?: number | undefined, pixelSizeInMm?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/updatephototour?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (newIntervallInMinutes === null)
            throw new Error("The parameter 'newIntervallInMinutes' cannot be null.");
        else if (newIntervallInMinutes !== undefined)
            url_ += "newIntervallInMinutes=" + encodeURIComponent("" + newIntervallInMinutes) + "&";
        if (pixelSizeInMm === null)
            throw new Error("The parameter 'pixelSizeInMm' cannot be null.");
        else if (pixelSizeInMm !== undefined)
            url_ += "pixelSizeInMm=" + encodeURIComponent("" + pixelSizeInMm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdatePhotoTour(_response));
        });
    }

    protected processUpdatePhotoTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    pausePhotoTour(id?: number | undefined, shouldBePaused?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/pausephototour?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (shouldBePaused === null)
            throw new Error("The parameter 'shouldBePaused' cannot be null.");
        else if (shouldBePaused !== undefined)
            url_ += "shouldBePaused=" + encodeURIComponent("" + shouldBePaused) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPausePhotoTour(_response));
        });
    }

    protected processPausePhotoTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getEvents(photoTourId?: number | undefined, allLogs?: boolean | undefined): Promise<PhotoTourEvent[]> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/events?";
        if (photoTourId === null)
            throw new Error("The parameter 'photoTourId' cannot be null.");
        else if (photoTourId !== undefined)
            url_ += "photoTourId=" + encodeURIComponent("" + photoTourId) + "&";
        if (allLogs === null)
            throw new Error("The parameter 'allLogs' cannot be null.");
        else if (allLogs !== undefined)
            url_ += "allLogs=" + encodeURIComponent("" + allLogs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetEvents(_response));
        });
    }

    protected processGetEvents(response: Response): Promise<PhotoTourEvent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourEvent[]>(null as any);
    }

    getPhotoTours(): Promise<PhotoTourInfo[]> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/phototours";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetPhotoTours(_response));
        });
    }

    protected processGetPhotoTours(response: Response): Promise<PhotoTourInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotoTourInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhotoTourInfo[]>(null as any);
    }

    startAutomaticTour(startInfo: AutomaticTourStartInfo): Promise<void> {
        let url_ = this.baseUrl + "/api/AutomaticPhotoTour/startphototour";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(startInfo);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStartAutomaticTour(_response));
        });
    }

    protected processStartAutomaticTour(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IAppConfigurationClient {

    updateDeviceSettings(password?: string | undefined, user?: string | undefined): Promise<void>;

    updateIpRanges(ipFrom?: string | undefined, ipTo?: string | undefined): Promise<void>;
}

export class AppConfigurationClient extends GatewayAppApiBase implements IAppConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    updateDeviceSettings(password?: string | undefined, user?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AppConfiguration/updatedevicesettings?";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateDeviceSettings(_response));
        });
    }

    protected processUpdateDeviceSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateIpRanges(ipFrom?: string | undefined, ipTo?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AppConfiguration/updateipranges?";
        if (ipFrom === null)
            throw new Error("The parameter 'ipFrom' cannot be null.");
        else if (ipFrom !== undefined)
            url_ += "ipFrom=" + encodeURIComponent("" + ipFrom) + "&";
        if (ipTo === null)
            throw new Error("The parameter 'ipTo' cannot be null.");
        else if (ipTo !== undefined)
            url_ += "ipTo=" + encodeURIComponent("" + ipTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateIpRanges(_response));
        });
    }

    protected processUpdateIpRanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RunningMeasurement implements IRunningMeasurement {
    ip!: string;
    measurementId!: number;

    constructor(data?: IRunningMeasurement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ip = _data["Ip"];
            this.measurementId = _data["MeasurementId"];
        }
    }

    static fromJS(data: any): RunningMeasurement {
        data = typeof data === 'object' ? data : {};
        let result = new RunningMeasurement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Ip"] = this.ip;
        data["MeasurementId"] = this.measurementId;
        return data;
    }

    clone(): RunningMeasurement {
        const json = this.toJSON();
        let result = new RunningMeasurement();
        result.init(json);
        return result;
    }
}

export interface IRunningMeasurement {
    ip: string;
    measurementId: number;
}

export class TemperatureMeasurement implements ITemperatureMeasurement {
    id!: number;
    comment!: string;
    sensorId!: string;
    startTime!: Date;
    photoTourFk!: number | undefined;
    deviceId!: string;
    finished!: boolean;
    photoTourFkNavigation!: AutomaticPhotoTour | undefined;
    temperatureMeasurementValues!: TemperatureMeasurementValue[];

    constructor(data?: ITemperatureMeasurement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.comment = _data["Comment"];
            this.sensorId = _data["SensorId"];
            this.startTime = _data["StartTime"] ? new Date(_data["StartTime"].toString()) : <any>undefined;
            this.photoTourFk = _data["PhotoTourFk"];
            this.deviceId = _data["DeviceId"];
            this.finished = _data["Finished"];
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            if (Array.isArray(_data["TemperatureMeasurementValues"])) {
                this.temperatureMeasurementValues = [] as any;
                for (let item of _data["TemperatureMeasurementValues"])
                    this.temperatureMeasurementValues!.push(TemperatureMeasurementValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemperatureMeasurement {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Comment"] = this.comment;
        data["SensorId"] = this.sensorId;
        data["StartTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["PhotoTourFk"] = this.photoTourFk;
        data["DeviceId"] = this.deviceId;
        data["Finished"] = this.finished;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.temperatureMeasurementValues)) {
            data["TemperatureMeasurementValues"] = [];
            for (let item of this.temperatureMeasurementValues)
                data["TemperatureMeasurementValues"].push(item.toJSON());
        }
        return data;
    }

    clone(): TemperatureMeasurement {
        const json = this.toJSON();
        let result = new TemperatureMeasurement();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurement {
    id: number;
    comment: string;
    sensorId: string;
    startTime: Date;
    photoTourFk: number | undefined;
    deviceId: string;
    finished: boolean;
    photoTourFkNavigation: AutomaticPhotoTour | undefined;
    temperatureMeasurementValues: TemperatureMeasurementValue[];
}

export class AutomaticPhotoTour implements IAutomaticPhotoTour {
    id!: number;
    deviceId!: string;
    name!: string;
    comment!: string;
    intervallInMinutes!: number;
    finished!: boolean;
    pixelSizeInMm!: number;
    photoTourEvents!: PhotoTourEvent[];
    photoTourPlants!: PhotoTourPlant[];
    photoTourTrips!: PhotoTourTrip[];
    temperatureMeasurements!: TemperatureMeasurement[];

    constructor(data?: IAutomaticPhotoTour) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.deviceId = _data["DeviceId"];
            this.name = _data["Name"];
            this.comment = _data["Comment"];
            this.intervallInMinutes = _data["IntervallInMinutes"];
            this.finished = _data["Finished"];
            this.pixelSizeInMm = _data["PixelSizeInMm"];
            if (Array.isArray(_data["PhotoTourEvents"])) {
                this.photoTourEvents = [] as any;
                for (let item of _data["PhotoTourEvents"])
                    this.photoTourEvents!.push(PhotoTourEvent.fromJS(item));
            }
            if (Array.isArray(_data["PhotoTourPlants"])) {
                this.photoTourPlants = [] as any;
                for (let item of _data["PhotoTourPlants"])
                    this.photoTourPlants!.push(PhotoTourPlant.fromJS(item));
            }
            if (Array.isArray(_data["PhotoTourTrips"])) {
                this.photoTourTrips = [] as any;
                for (let item of _data["PhotoTourTrips"])
                    this.photoTourTrips!.push(PhotoTourTrip.fromJS(item));
            }
            if (Array.isArray(_data["TemperatureMeasurements"])) {
                this.temperatureMeasurements = [] as any;
                for (let item of _data["TemperatureMeasurements"])
                    this.temperatureMeasurements!.push(TemperatureMeasurement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutomaticPhotoTour {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticPhotoTour();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DeviceId"] = this.deviceId;
        data["Name"] = this.name;
        data["Comment"] = this.comment;
        data["IntervallInMinutes"] = this.intervallInMinutes;
        data["Finished"] = this.finished;
        data["PixelSizeInMm"] = this.pixelSizeInMm;
        if (Array.isArray(this.photoTourEvents)) {
            data["PhotoTourEvents"] = [];
            for (let item of this.photoTourEvents)
                data["PhotoTourEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.photoTourPlants)) {
            data["PhotoTourPlants"] = [];
            for (let item of this.photoTourPlants)
                data["PhotoTourPlants"].push(item.toJSON());
        }
        if (Array.isArray(this.photoTourTrips)) {
            data["PhotoTourTrips"] = [];
            for (let item of this.photoTourTrips)
                data["PhotoTourTrips"].push(item.toJSON());
        }
        if (Array.isArray(this.temperatureMeasurements)) {
            data["TemperatureMeasurements"] = [];
            for (let item of this.temperatureMeasurements)
                data["TemperatureMeasurements"].push(item.toJSON());
        }
        return data;
    }

    clone(): AutomaticPhotoTour {
        const json = this.toJSON();
        let result = new AutomaticPhotoTour();
        result.init(json);
        return result;
    }
}

export interface IAutomaticPhotoTour {
    id: number;
    deviceId: string;
    name: string;
    comment: string;
    intervallInMinutes: number;
    finished: boolean;
    pixelSizeInMm: number;
    photoTourEvents: PhotoTourEvent[];
    photoTourPlants: PhotoTourPlant[];
    photoTourTrips: PhotoTourTrip[];
    temperatureMeasurements: TemperatureMeasurement[];
}

export class PhotoTourEvent implements IPhotoTourEvent {
    id!: number;
    photoTourFk!: number;
    message!: string;
    timestamp!: Date;
    photoTourFkNavigation!: AutomaticPhotoTour;
    type!: PhotoTourEventType;

    constructor(data?: IPhotoTourEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTourFk = _data["PhotoTourFk"];
            this.message = _data["Message"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): PhotoTourEvent {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTourFk"] = this.photoTourFk;
        data["Message"] = this.message;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        data["Type"] = this.type;
        return data;
    }

    clone(): PhotoTourEvent {
        const json = this.toJSON();
        let result = new PhotoTourEvent();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourEvent {
    id: number;
    photoTourFk: number;
    message: string;
    timestamp: Date;
    photoTourFkNavigation: AutomaticPhotoTour;
    type: PhotoTourEventType;
}

export enum PhotoTourEventType {
    Debug = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
}

export class PhotoTourPlant implements IPhotoTourPlant {
    id!: number;
    name!: string;
    comment!: string;
    position!: string | undefined;
    photoTourFk!: number;
    photoTourFkNavigation!: AutomaticPhotoTour;
    plantExtractionTemplates!: PlantExtractionTemplate[];

    constructor(data?: IPhotoTourPlant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.comment = _data["Comment"];
            this.position = _data["Position"];
            this.photoTourFk = _data["PhotoTourFk"];
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            if (Array.isArray(_data["PlantExtractionTemplates"])) {
                this.plantExtractionTemplates = [] as any;
                for (let item of _data["PlantExtractionTemplates"])
                    this.plantExtractionTemplates!.push(PlantExtractionTemplate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhotoTourPlant {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourPlant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Comment"] = this.comment;
        data["Position"] = this.position;
        data["PhotoTourFk"] = this.photoTourFk;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.plantExtractionTemplates)) {
            data["PlantExtractionTemplates"] = [];
            for (let item of this.plantExtractionTemplates)
                data["PlantExtractionTemplates"].push(item.toJSON());
        }
        return data;
    }

    clone(): PhotoTourPlant {
        const json = this.toJSON();
        let result = new PhotoTourPlant();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourPlant {
    id: number;
    name: string;
    comment: string;
    position: string | undefined;
    photoTourFk: number;
    photoTourFkNavigation: AutomaticPhotoTour;
    plantExtractionTemplates: PlantExtractionTemplate[];
}

export class PlantExtractionTemplate implements IPlantExtractionTemplate {
    id!: number;
    photoTripFk!: number;
    photoTourPlantFk!: number;
    photoBoundingBox!: NpgsqlPoint[];
    irBoundingBoxOffset!: NpgsqlPoint;
    boundingBoxHeight!: number;
    boundingBoxWidth!: number;
    motorPosition!: number;
    photoTourPlantFkNavigation!: PhotoTourPlant;
    photoTripFkNavigation!: PhotoTourTrip;

    constructor(data?: IPlantExtractionTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTripFk = _data["PhotoTripFk"];
            this.photoTourPlantFk = _data["PhotoTourPlantFk"];
            if (Array.isArray(_data["PhotoBoundingBox"])) {
                this.photoBoundingBox = [] as any;
                for (let item of _data["PhotoBoundingBox"])
                    this.photoBoundingBox!.push(NpgsqlPoint.fromJS(item));
            }
            this.irBoundingBoxOffset = _data["IrBoundingBoxOffset"] ? NpgsqlPoint.fromJS(_data["IrBoundingBoxOffset"]) : <any>undefined;
            this.boundingBoxHeight = _data["BoundingBoxHeight"];
            this.boundingBoxWidth = _data["BoundingBoxWidth"];
            this.motorPosition = _data["MotorPosition"];
            this.photoTourPlantFkNavigation = _data["PhotoTourPlantFkNavigation"] ? PhotoTourPlant.fromJS(_data["PhotoTourPlantFkNavigation"]) : <any>undefined;
            this.photoTripFkNavigation = _data["PhotoTripFkNavigation"] ? PhotoTourTrip.fromJS(_data["PhotoTripFkNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PlantExtractionTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new PlantExtractionTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTripFk"] = this.photoTripFk;
        data["PhotoTourPlantFk"] = this.photoTourPlantFk;
        if (Array.isArray(this.photoBoundingBox)) {
            data["PhotoBoundingBox"] = [];
            for (let item of this.photoBoundingBox)
                data["PhotoBoundingBox"].push(item.toJSON());
        }
        data["IrBoundingBoxOffset"] = this.irBoundingBoxOffset ? this.irBoundingBoxOffset.toJSON() : <any>undefined;
        data["BoundingBoxHeight"] = this.boundingBoxHeight;
        data["BoundingBoxWidth"] = this.boundingBoxWidth;
        data["MotorPosition"] = this.motorPosition;
        data["PhotoTourPlantFkNavigation"] = this.photoTourPlantFkNavigation ? this.photoTourPlantFkNavigation.toJSON() : <any>undefined;
        data["PhotoTripFkNavigation"] = this.photoTripFkNavigation ? this.photoTripFkNavigation.toJSON() : <any>undefined;
        return data;
    }

    clone(): PlantExtractionTemplate {
        const json = this.toJSON();
        let result = new PlantExtractionTemplate();
        result.init(json);
        return result;
    }
}

export interface IPlantExtractionTemplate {
    id: number;
    photoTripFk: number;
    photoTourPlantFk: number;
    photoBoundingBox: NpgsqlPoint[];
    irBoundingBoxOffset: NpgsqlPoint;
    boundingBoxHeight: number;
    boundingBoxWidth: number;
    motorPosition: number;
    photoTourPlantFkNavigation: PhotoTourPlant;
    photoTripFkNavigation: PhotoTourTrip;
}

/** Represents a PostgreSQL point type. */
export class NpgsqlPoint implements INpgsqlPoint {
    x!: number;
    y!: number;

    constructor(data?: INpgsqlPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["X"];
            this.y = _data["Y"];
        }
    }

    static fromJS(data: any): NpgsqlPoint {
        data = typeof data === 'object' ? data : {};
        let result = new NpgsqlPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["X"] = this.x;
        data["Y"] = this.y;
        return data;
    }

    clone(): NpgsqlPoint {
        const json = this.toJSON();
        let result = new NpgsqlPoint();
        result.init(json);
        return result;
    }
}

/** Represents a PostgreSQL point type. */
export interface INpgsqlPoint {
    x: number;
    y: number;
}

export class PhotoTourTrip implements IPhotoTourTrip {
    id!: number;
    photoTourFk!: number;
    irDataFolder!: string;
    visDataFolder!: string;
    timestamp!: Date;
    virtualPicturePath!: string | undefined;
    segmentationTemplate!: string | undefined;
    photoTourFkNavigation!: AutomaticPhotoTour;
    plantExtractionTemplates!: PlantExtractionTemplate[];
    segmentationTemplateJson!: SegmentationTemplate | undefined;

    constructor(data?: IPhotoTourTrip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTourFk = _data["PhotoTourFk"];
            this.irDataFolder = _data["IrDataFolder"];
            this.visDataFolder = _data["VisDataFolder"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.virtualPicturePath = _data["VirtualPicturePath"];
            this.segmentationTemplate = _data["SegmentationTemplate"];
            this.photoTourFkNavigation = _data["PhotoTourFkNavigation"] ? AutomaticPhotoTour.fromJS(_data["PhotoTourFkNavigation"]) : <any>undefined;
            if (Array.isArray(_data["PlantExtractionTemplates"])) {
                this.plantExtractionTemplates = [] as any;
                for (let item of _data["PlantExtractionTemplates"])
                    this.plantExtractionTemplates!.push(PlantExtractionTemplate.fromJS(item));
            }
            this.segmentationTemplateJson = _data["SegmentationTemplateJson"] ? SegmentationTemplate.fromJS(_data["SegmentationTemplateJson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoTourTrip {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourTrip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTourFk"] = this.photoTourFk;
        data["IrDataFolder"] = this.irDataFolder;
        data["VisDataFolder"] = this.visDataFolder;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["VirtualPicturePath"] = this.virtualPicturePath;
        data["SegmentationTemplate"] = this.segmentationTemplate;
        data["PhotoTourFkNavigation"] = this.photoTourFkNavigation ? this.photoTourFkNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.plantExtractionTemplates)) {
            data["PlantExtractionTemplates"] = [];
            for (let item of this.plantExtractionTemplates)
                data["PlantExtractionTemplates"].push(item.toJSON());
        }
        data["SegmentationTemplateJson"] = this.segmentationTemplateJson ? this.segmentationTemplateJson.toJSON() : <any>undefined;
        return data;
    }

    clone(): PhotoTourTrip {
        const json = this.toJSON();
        let result = new PhotoTourTrip();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourTrip {
    id: number;
    photoTourFk: number;
    irDataFolder: string;
    visDataFolder: string;
    timestamp: Date;
    virtualPicturePath: string | undefined;
    segmentationTemplate: string | undefined;
    photoTourFkNavigation: AutomaticPhotoTour;
    plantExtractionTemplates: PlantExtractionTemplate[];
    segmentationTemplateJson: SegmentationTemplate | undefined;
}

export class SegmentationTemplate implements ISegmentationTemplate {
    hLow!: number;
    hHigh!: number;
    sLow!: number;
    sHigh!: number;
    lLow!: number;
    lHigh!: number;
    useOtsu!: boolean;
    openingIterations!: number;

    constructor(data?: ISegmentationTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hLow = _data["HLow"];
            this.hHigh = _data["HHigh"];
            this.sLow = _data["SLow"];
            this.sHigh = _data["SHigh"];
            this.lLow = _data["LLow"];
            this.lHigh = _data["LHigh"];
            this.useOtsu = _data["UseOtsu"];
            this.openingIterations = _data["OpeningIterations"];
        }
    }

    static fromJS(data: any): SegmentationTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentationTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HLow"] = this.hLow;
        data["HHigh"] = this.hHigh;
        data["SLow"] = this.sLow;
        data["SHigh"] = this.sHigh;
        data["LLow"] = this.lLow;
        data["LHigh"] = this.lHigh;
        data["UseOtsu"] = this.useOtsu;
        data["OpeningIterations"] = this.openingIterations;
        return data;
    }

    clone(): SegmentationTemplate {
        const json = this.toJSON();
        let result = new SegmentationTemplate();
        result.init(json);
        return result;
    }
}

export interface ISegmentationTemplate {
    hLow: number;
    hHigh: number;
    sLow: number;
    sHigh: number;
    lLow: number;
    lHigh: number;
    useOtsu: boolean;
    openingIterations: number;
}

export class TemperatureMeasurementValue implements ITemperatureMeasurementValue {
    id!: number;
    temperature!: number;
    timestamp!: Date;
    measurementFk!: number;
    measurementFkNavigation!: TemperatureMeasurement;

    constructor(data?: ITemperatureMeasurementValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.temperature = _data["Temperature"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.measurementFk = _data["MeasurementFk"];
            this.measurementFkNavigation = _data["MeasurementFkNavigation"] ? TemperatureMeasurement.fromJS(_data["MeasurementFkNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TemperatureMeasurementValue {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurementValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Temperature"] = this.temperature;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["MeasurementFk"] = this.measurementFk;
        data["MeasurementFkNavigation"] = this.measurementFkNavigation ? this.measurementFkNavigation.toJSON() : <any>undefined;
        return data;
    }

    clone(): TemperatureMeasurementValue {
        const json = this.toJSON();
        let result = new TemperatureMeasurementValue();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurementValue {
    id: number;
    temperature: number;
    timestamp: Date;
    measurementFk: number;
    measurementFkNavigation: TemperatureMeasurement;
}

export class MeasurementTemperatureDatum implements IMeasurementTemperatureDatum {
    temperature!: number;
    timestamp!: Date;

    constructor(data?: IMeasurementTemperatureDatum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["Temperature"];
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MeasurementTemperatureDatum {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementTemperatureDatum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Temperature"] = this.temperature;
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }

    clone(): MeasurementTemperatureDatum {
        const json = this.toJSON();
        let result = new MeasurementTemperatureDatum();
        result.init(json);
        return result;
    }
}

export interface IMeasurementTemperatureDatum {
    temperature: number;
    timestamp: Date;
}

export class MeasurementStartInfo implements IMeasurementStartInfo {
    devices!: MeasurementDevice[];
    ip!: string;

    constructor(data?: IMeasurementStartInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Devices"])) {
                this.devices = [] as any;
                for (let item of _data["Devices"])
                    this.devices!.push(MeasurementDevice.fromJS(item));
            }
            this.ip = _data["Ip"];
        }
    }

    static fromJS(data: any): MeasurementStartInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementStartInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devices)) {
            data["Devices"] = [];
            for (let item of this.devices)
                data["Devices"].push(item.toJSON());
        }
        data["Ip"] = this.ip;
        return data;
    }

    clone(): MeasurementStartInfo {
        const json = this.toJSON();
        let result = new MeasurementStartInfo();
        result.init(json);
        return result;
    }
}

export interface IMeasurementStartInfo {
    devices: MeasurementDevice[];
    ip: string;
}

export class MeasurementDevice implements IMeasurementDevice {
    sensorId!: string;
    comment!: string;

    constructor(data?: IMeasurementDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sensorId = _data["SensorId"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): MeasurementDevice {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SensorId"] = this.sensorId;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): MeasurementDevice {
        const json = this.toJSON();
        let result = new MeasurementDevice();
        result.init(json);
        return result;
    }
}

export interface IMeasurementDevice {
    sensorId: string;
    comment: string;
}

export class PhotoTourPlantInfo implements IPhotoTourPlantInfo {
    id!: number;
    name!: string;
    comment!: string;
    position!: string | undefined;
    photoTourFk!: number;
    extractionMetaData!: ExtractionMetaData[];

    constructor(data?: IPhotoTourPlantInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.comment = _data["Comment"];
            this.position = _data["Position"];
            this.photoTourFk = _data["PhotoTourFk"];
            if (Array.isArray(_data["ExtractionMetaData"])) {
                this.extractionMetaData = [] as any;
                for (let item of _data["ExtractionMetaData"])
                    this.extractionMetaData!.push(ExtractionMetaData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhotoTourPlantInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourPlantInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Comment"] = this.comment;
        data["Position"] = this.position;
        data["PhotoTourFk"] = this.photoTourFk;
        if (Array.isArray(this.extractionMetaData)) {
            data["ExtractionMetaData"] = [];
            for (let item of this.extractionMetaData)
                data["ExtractionMetaData"].push(item.toJSON());
        }
        return data;
    }

    clone(): PhotoTourPlantInfo {
        const json = this.toJSON();
        let result = new PhotoTourPlantInfo();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourPlantInfo {
    id: number;
    name: string;
    comment: string;
    position: string | undefined;
    photoTourFk: number;
    extractionMetaData: ExtractionMetaData[];
}

export class ExtractionMetaData implements IExtractionMetaData {
    tripWithExtraction!: number;
    motorPosition!: number;
    extractionTime!: Date;

    constructor(data?: IExtractionMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tripWithExtraction = _data["TripWithExtraction"];
            this.motorPosition = _data["MotorPosition"];
            this.extractionTime = _data["ExtractionTime"] ? new Date(_data["ExtractionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtractionMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new ExtractionMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TripWithExtraction"] = this.tripWithExtraction;
        data["MotorPosition"] = this.motorPosition;
        data["ExtractionTime"] = this.extractionTime ? this.extractionTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): ExtractionMetaData {
        const json = this.toJSON();
        let result = new ExtractionMetaData();
        result.init(json);
        return result;
    }
}

export interface IExtractionMetaData {
    tripWithExtraction: number;
    motorPosition: number;
    extractionTime: Date;
}

export class PlantExtractionTemplateModel implements IPlantExtractionTemplateModel {
    id!: number;
    photoTripFk!: number;
    photoTourPlantFk!: number;
    photoBoundingBox!: NpgsqlPoint[];
    irBoundingBoxOffset!: NpgsqlPoint;
    motorPosition!: number;
    applicablePhotoTripFrom!: Date;

    constructor(data?: IPlantExtractionTemplateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.photoTripFk = _data["PhotoTripFk"];
            this.photoTourPlantFk = _data["PhotoTourPlantFk"];
            if (Array.isArray(_data["PhotoBoundingBox"])) {
                this.photoBoundingBox = [] as any;
                for (let item of _data["PhotoBoundingBox"])
                    this.photoBoundingBox!.push(NpgsqlPoint.fromJS(item));
            }
            this.irBoundingBoxOffset = _data["IrBoundingBoxOffset"] ? NpgsqlPoint.fromJS(_data["IrBoundingBoxOffset"]) : <any>undefined;
            this.motorPosition = _data["MotorPosition"];
            this.applicablePhotoTripFrom = _data["ApplicablePhotoTripFrom"] ? new Date(_data["ApplicablePhotoTripFrom"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PlantExtractionTemplateModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlantExtractionTemplateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["PhotoTripFk"] = this.photoTripFk;
        data["PhotoTourPlantFk"] = this.photoTourPlantFk;
        if (Array.isArray(this.photoBoundingBox)) {
            data["PhotoBoundingBox"] = [];
            for (let item of this.photoBoundingBox)
                data["PhotoBoundingBox"].push(item.toJSON());
        }
        data["IrBoundingBoxOffset"] = this.irBoundingBoxOffset ? this.irBoundingBoxOffset.toJSON() : <any>undefined;
        data["MotorPosition"] = this.motorPosition;
        data["ApplicablePhotoTripFrom"] = this.applicablePhotoTripFrom ? this.applicablePhotoTripFrom.toISOString() : <any>undefined;
        return data;
    }

    clone(): PlantExtractionTemplateModel {
        const json = this.toJSON();
        let result = new PlantExtractionTemplateModel();
        result.init(json);
        return result;
    }
}

export interface IPlantExtractionTemplateModel {
    id: number;
    photoTripFk: number;
    photoTourPlantFk: number;
    photoBoundingBox: NpgsqlPoint[];
    irBoundingBoxOffset: NpgsqlPoint;
    motorPosition: number;
    applicablePhotoTripFrom: Date;
}

export class ImageCropPreview implements IImageCropPreview {
    irImage!: string;
    visImage!: string;
    currentOffset!: NpgsqlPoint;
    previousOffset!: NpgsqlPoint;

    constructor(data?: IImageCropPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.irImage = _data["IrImage"];
            this.visImage = _data["VisImage"];
            this.currentOffset = _data["CurrentOffset"] ? NpgsqlPoint.fromJS(_data["CurrentOffset"]) : <any>undefined;
            this.previousOffset = _data["PreviousOffset"] ? NpgsqlPoint.fromJS(_data["PreviousOffset"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ImageCropPreview {
        data = typeof data === 'object' ? data : {};
        let result = new ImageCropPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IrImage"] = this.irImage;
        data["VisImage"] = this.visImage;
        data["CurrentOffset"] = this.currentOffset ? this.currentOffset.toJSON() : <any>undefined;
        data["PreviousOffset"] = this.previousOffset ? this.previousOffset.toJSON() : <any>undefined;
        return data;
    }

    clone(): ImageCropPreview {
        const json = this.toJSON();
        let result = new ImageCropPreview();
        result.init(json);
        return result;
    }
}

export interface IImageCropPreview {
    irImage: string;
    visImage: string;
    currentOffset: NpgsqlPoint;
    previousOffset: NpgsqlPoint;
}

export class IrOffsetFineAdjustment implements IIrOffsetFineAdjustment {
    extractionTemplateId!: number;
    newIrOffset!: NpgsqlPoint;

    constructor(data?: IIrOffsetFineAdjustment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.extractionTemplateId = _data["ExtractionTemplateId"];
            this.newIrOffset = _data["NewIrOffset"] ? NpgsqlPoint.fromJS(_data["NewIrOffset"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IrOffsetFineAdjustment {
        data = typeof data === 'object' ? data : {};
        let result = new IrOffsetFineAdjustment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ExtractionTemplateId"] = this.extractionTemplateId;
        data["NewIrOffset"] = this.newIrOffset ? this.newIrOffset.toJSON() : <any>undefined;
        return data;
    }

    clone(): IrOffsetFineAdjustment {
        const json = this.toJSON();
        let result = new IrOffsetFineAdjustment();
        result.init(json);
        return result;
    }
}

export interface IIrOffsetFineAdjustment {
    extractionTemplateId: number;
    newIrOffset: NpgsqlPoint;
}

export class PlantImageSection implements IPlantImageSection {
    stepCount!: number;
    photoTripId!: number;
    polygon!: NpgsqlPoint[];
    irPolygonOffset!: NpgsqlPoint;
    plantId!: number;

    constructor(data?: IPlantImageSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepCount = _data["StepCount"];
            this.photoTripId = _data["PhotoTripId"];
            if (Array.isArray(_data["Polygon"])) {
                this.polygon = [] as any;
                for (let item of _data["Polygon"])
                    this.polygon!.push(NpgsqlPoint.fromJS(item));
            }
            this.irPolygonOffset = _data["IrPolygonOffset"] ? NpgsqlPoint.fromJS(_data["IrPolygonOffset"]) : <any>undefined;
            this.plantId = _data["PlantId"];
        }
    }

    static fromJS(data: any): PlantImageSection {
        data = typeof data === 'object' ? data : {};
        let result = new PlantImageSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StepCount"] = this.stepCount;
        data["PhotoTripId"] = this.photoTripId;
        if (Array.isArray(this.polygon)) {
            data["Polygon"] = [];
            for (let item of this.polygon)
                data["Polygon"].push(item.toJSON());
        }
        data["IrPolygonOffset"] = this.irPolygonOffset ? this.irPolygonOffset.toJSON() : <any>undefined;
        data["PlantId"] = this.plantId;
        return data;
    }

    clone(): PlantImageSection {
        const json = this.toJSON();
        let result = new PlantImageSection();
        result.init(json);
        return result;
    }
}

export interface IPlantImageSection {
    stepCount: number;
    photoTripId: number;
    polygon: NpgsqlPoint[];
    irPolygonOffset: NpgsqlPoint;
    plantId: number;
}

export class AddPlantModel implements IAddPlantModel {
    plants!: PlantModel[];
    tourId!: number;

    constructor(data?: IAddPlantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Plants"])) {
                this.plants = [] as any;
                for (let item of _data["Plants"])
                    this.plants!.push(PlantModel.fromJS(item));
            }
            this.tourId = _data["TourId"];
        }
    }

    static fromJS(data: any): AddPlantModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddPlantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.plants)) {
            data["Plants"] = [];
            for (let item of this.plants)
                data["Plants"].push(item.toJSON());
        }
        data["TourId"] = this.tourId;
        return data;
    }

    clone(): AddPlantModel {
        const json = this.toJSON();
        let result = new AddPlantModel();
        result.init(json);
        return result;
    }
}

export interface IAddPlantModel {
    plants: PlantModel[];
    tourId: number;
}

export class PlantModel implements IPlantModel {
    name!: string;
    comment!: string;
    position!: string;

    constructor(data?: IPlantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.comment = _data["Comment"];
            this.position = _data["Position"];
        }
    }

    static fromJS(data: any): PlantModel {
        data = typeof data === 'object' ? data : {};
        let result = new PlantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Comment"] = this.comment;
        data["Position"] = this.position;
        return data;
    }

    clone(): PlantModel {
        const json = this.toJSON();
        let result = new PlantModel();
        result.init(json);
        return result;
    }
}

export interface IPlantModel {
    name: string;
    comment: string;
    position: string;
}

export class SeriesByDevice implements ISeriesByDevice {
    deviceId!: string;
    folderName!: string;

    constructor(data?: ISeriesByDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["DeviceId"];
            this.folderName = _data["FolderName"];
        }
    }

    static fromJS(data: any): SeriesByDevice {
        data = typeof data === 'object' ? data : {};
        let result = new SeriesByDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeviceId"] = this.deviceId;
        data["FolderName"] = this.folderName;
        return data;
    }

    clone(): SeriesByDevice {
        const json = this.toJSON();
        let result = new SeriesByDevice();
        result.init(json);
        return result;
    }
}

export interface ISeriesByDevice {
    deviceId: string;
    folderName: string;
}

export class IrCameraOffset implements IIrCameraOffset {
    left!: number | undefined;
    top!: number | undefined;

    constructor(data?: IIrCameraOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.left = _data["left"];
            this.top = _data["top"];
        }
    }

    static fromJS(data: any): IrCameraOffset {
        data = typeof data === 'object' ? data : {};
        let result = new IrCameraOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["left"] = this.left;
        data["top"] = this.top;
        return data;
    }

    clone(): IrCameraOffset {
        const json = this.toJSON();
        let result = new IrCameraOffset();
        result.init(json);
        return result;
    }
}

export interface IIrCameraOffset {
    left: number | undefined;
    top: number | undefined;
}

export class PictureSeriesData implements IPictureSeriesData {
    count!: number;
    folderName!: string;
    type!: CameraType | undefined;

    constructor(data?: IPictureSeriesData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["Count"];
            this.folderName = _data["FolderName"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): PictureSeriesData {
        data = typeof data === 'object' ? data : {};
        let result = new PictureSeriesData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Count"] = this.count;
        data["FolderName"] = this.folderName;
        data["Type"] = this.type;
        return data;
    }

    clone(): PictureSeriesData {
        const json = this.toJSON();
        let result = new PictureSeriesData();
        result.init(json);
        return result;
    }
}

export interface IPictureSeriesData {
    count: number;
    folderName: string;
    type: CameraType | undefined;
}

export enum CameraType {
    Vis = 0,
    IR = 1,
}

export class PictureTripData implements IPictureTripData {
    irData!: PictureSeriesData;
    visData!: PictureSeriesData;
    timeStamp!: Date;
    deviceId!: string;
    tripId!: number;

    constructor(data?: IPictureTripData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.irData = _data["IrData"] ? PictureSeriesData.fromJS(_data["IrData"]) : <any>undefined;
            this.visData = _data["VisData"] ? PictureSeriesData.fromJS(_data["VisData"]) : <any>undefined;
            this.timeStamp = _data["TimeStamp"] ? new Date(_data["TimeStamp"].toString()) : <any>undefined;
            this.deviceId = _data["DeviceId"];
            this.tripId = _data["TripId"];
        }
    }

    static fromJS(data: any): PictureTripData {
        data = typeof data === 'object' ? data : {};
        let result = new PictureTripData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IrData"] = this.irData ? this.irData.toJSON() : <any>undefined;
        data["VisData"] = this.visData ? this.visData.toJSON() : <any>undefined;
        data["TimeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["DeviceId"] = this.deviceId;
        data["TripId"] = this.tripId;
        return data;
    }

    clone(): PictureTripData {
        const json = this.toJSON();
        let result = new PictureTripData();
        result.init(json);
        return result;
    }
}

export interface IPictureTripData {
    irData: PictureSeriesData;
    visData: PictureSeriesData;
    timeStamp: Date;
    deviceId: string;
    tripId: number;
}

export class DeviceMovement implements IDeviceMovement {
    id!: number;
    deviceId!: string;
    movementPlanJson!: string;
    name!: string;
    movementPlan!: MovementPlan;

    constructor(data?: IDeviceMovement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.deviceId = _data["DeviceId"];
            this.movementPlanJson = _data["MovementPlanJson"];
            this.name = _data["Name"];
            this.movementPlan = _data["MovementPlan"] ? MovementPlan.fromJS(_data["MovementPlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceMovement {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceMovement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DeviceId"] = this.deviceId;
        data["MovementPlanJson"] = this.movementPlanJson;
        data["Name"] = this.name;
        data["MovementPlan"] = this.movementPlan ? this.movementPlan.toJSON() : <any>undefined;
        return data;
    }

    clone(): DeviceMovement {
        const json = this.toJSON();
        let result = new DeviceMovement();
        result.init(json);
        return result;
    }
}

export interface IDeviceMovement {
    id: number;
    deviceId: string;
    movementPlanJson: string;
    name: string;
    movementPlan: MovementPlan;
}

export class MovementPlan implements IMovementPlan {
    stepPoints!: MovementPoint[];

    constructor(data?: IMovementPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["StepPoints"])) {
                this.stepPoints = [] as any;
                for (let item of _data["StepPoints"])
                    this.stepPoints!.push(MovementPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MovementPlan {
        data = typeof data === 'object' ? data : {};
        let result = new MovementPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stepPoints)) {
            data["StepPoints"] = [];
            for (let item of this.stepPoints)
                data["StepPoints"].push(item.toJSON());
        }
        return data;
    }

    clone(): MovementPlan {
        const json = this.toJSON();
        let result = new MovementPlan();
        result.init(json);
        return result;
    }
}

export interface IMovementPlan {
    stepPoints: MovementPoint[];
}

export class MovementPoint implements IMovementPoint {
    stepOffset!: number;
    focusInCentimeter!: number;
    speed!: number;
    comment!: string;

    constructor(data?: IMovementPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stepOffset = _data["StepOffset"];
            this.focusInCentimeter = _data["FocusInCentimeter"];
            this.speed = _data["Speed"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): MovementPoint {
        data = typeof data === 'object' ? data : {};
        let result = new MovementPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StepOffset"] = this.stepOffset;
        data["FocusInCentimeter"] = this.focusInCentimeter;
        data["Speed"] = this.speed;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): MovementPoint {
        const json = this.toJSON();
        let result = new MovementPoint();
        result.init(json);
        return result;
    }
}

export interface IMovementPoint {
    stepOffset: number;
    focusInCentimeter: number;
    speed: number;
    comment: string;
}

export class AssociatePowerOutletModel implements IAssociatePowerOutletModel {
    deviceId!: string;
    switchOnId!: number | undefined;
    switchOffId!: number | undefined;

    constructor(data?: IAssociatePowerOutletModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["DeviceId"];
            this.switchOnId = _data["SwitchOnId"];
            this.switchOffId = _data["SwitchOffId"];
        }
    }

    static fromJS(data: any): AssociatePowerOutletModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatePowerOutletModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DeviceId"] = this.deviceId;
        data["SwitchOnId"] = this.switchOnId;
        data["SwitchOffId"] = this.switchOffId;
        return data;
    }

    clone(): AssociatePowerOutletModel {
        const json = this.toJSON();
        let result = new AssociatePowerOutletModel();
        result.init(json);
        return result;
    }
}

export interface IAssociatePowerOutletModel {
    deviceId: string;
    switchOnId: number | undefined;
    switchOffId: number | undefined;
}

export class OutletModel implements IOutletModel {
    switchOnId!: number;
    switchOffId!: number;
    name!: string;
    buttonNumber!: number;
    channel!: number;

    constructor(data?: IOutletModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchOnId = _data["SwitchOnId"];
            this.switchOffId = _data["SwitchOffId"];
            this.name = _data["Name"];
            this.buttonNumber = _data["ButtonNumber"];
            this.channel = _data["Channel"];
        }
    }

    static fromJS(data: any): OutletModel {
        data = typeof data === 'object' ? data : {};
        let result = new OutletModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SwitchOnId"] = this.switchOnId;
        data["SwitchOffId"] = this.switchOffId;
        data["Name"] = this.name;
        data["ButtonNumber"] = this.buttonNumber;
        data["Channel"] = this.channel;
        return data;
    }

    clone(): OutletModel {
        const json = this.toJSON();
        let result = new OutletModel();
        result.init(json);
        return result;
    }
}

export interface IOutletModel {
    switchOnId: number;
    switchOffId: number;
    name: string;
    buttonNumber: number;
    channel: number;
}

export class MotorPosition implements IMotorPosition {
    engaged!: boolean | undefined;
    position!: number | undefined;
    dirty!: boolean | undefined;

    constructor(data?: IMotorPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.engaged = _data["engaged"];
            this.position = _data["position"];
            this.dirty = _data["dirty"];
        }
    }

    static fromJS(data: any): MotorPosition {
        data = typeof data === 'object' ? data : {};
        let result = new MotorPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["engaged"] = this.engaged;
        data["position"] = this.position;
        data["dirty"] = this.dirty;
        return data;
    }

    clone(): MotorPosition {
        const json = this.toJSON();
        let result = new MotorPosition();
        result.init(json);
        return result;
    }
}

export interface IMotorPosition {
    engaged: boolean | undefined;
    position: number | undefined;
    dirty: boolean | undefined;
}

export class CertificateData implements ICertificateData {
    certificate!: string;
    key!: string;

    constructor(data?: ICertificateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificate = _data["Certificate"];
            this.key = _data["Key"];
        }
    }

    static fromJS(data: any): CertificateData {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Certificate"] = this.certificate;
        data["Key"] = this.key;
        return data;
    }

    clone(): CertificateData {
        const json = this.toJSON();
        let result = new CertificateData();
        result.init(json);
        return result;
    }
}

export interface ICertificateData {
    certificate: string;
    key: string;
}

export class WebSshCredentials implements IWebSshCredentials {
    protocol!: string;
    port!: string;
    password!: string;
    user!: string;

    constructor(data?: IWebSshCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocol = _data["Protocol"];
            this.port = _data["Port"];
            this.password = _data["Password"];
            this.user = _data["User"];
        }
    }

    static fromJS(data: any): WebSshCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new WebSshCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Protocol"] = this.protocol;
        data["Port"] = this.port;
        data["Password"] = this.password;
        data["User"] = this.user;
        return data;
    }

    clone(): WebSshCredentials {
        const json = this.toJSON();
        let result = new WebSshCredentials();
        result.init(json);
        return result;
    }
}

export interface IWebSshCredentials {
    protocol: string;
    port: string;
    password: string;
    user: string;
}

export class DeviceHealth implements IDeviceHealth {
    deviceName!: string | undefined;
    deviceId!: string | undefined;
    state!: HealthState | undefined;
    cameraOffset!: IrCameraOffset | undefined;

    constructor(data?: IDeviceHealth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceName = _data["deviceName"];
            this.deviceId = _data["deviceId"];
            this.state = _data["state"];
            this.cameraOffset = _data["cameraOffset"] ? IrCameraOffset.fromJS(_data["cameraOffset"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceHealth {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHealth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        data["state"] = this.state;
        data["cameraOffset"] = this.cameraOffset ? this.cameraOffset.toJSON() : <any>undefined;
        return data;
    }

    clone(): DeviceHealth {
        const json = this.toJSON();
        let result = new DeviceHealth();
        result.init(json);
        return result;
    }
}

export interface IDeviceHealth {
    deviceName: string | undefined;
    deviceId: string | undefined;
    state: HealthState | undefined;
    cameraOffset: IrCameraOffset | undefined;
}

export enum HealthState {
    NA = 0,
    NoirCameraFound = 1,
    ThermalCameraFound = 2,
    NoirCameraFunctional = 4,
    ThermalCameraFunctional = 8,
    HasTemperatureSensor = 16,
    CanSwitchOutlets = 32,
}

export class DeviceHealthState implements IDeviceHealthState {
    health!: DeviceHealth;
    retryTimes!: number;
    ip!: string;

    constructor(data?: IDeviceHealthState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.health = _data["Health"] ? DeviceHealth.fromJS(_data["Health"]) : <any>undefined;
            this.retryTimes = _data["RetryTimes"];
            this.ip = _data["Ip"];
        }
    }

    static fromJS(data: any): DeviceHealthState {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHealthState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Health"] = this.health ? this.health.toJSON() : <any>undefined;
        data["RetryTimes"] = this.retryTimes;
        data["Ip"] = this.ip;
        return data;
    }

    clone(): DeviceHealthState {
        const json = this.toJSON();
        let result = new DeviceHealthState();
        result.init(json);
        return result;
    }
}

export interface IDeviceHealthState {
    health: DeviceHealth;
    retryTimes: number;
    ip: string;
}

export class VirtualImageInfo implements IVirtualImageInfo {
    name!: string;
    creationDate!: Date;

    constructor(data?: IVirtualImageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.creationDate = _data["CreationDate"] ? new Date(_data["CreationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VirtualImageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualImageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["CreationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): VirtualImageInfo {
        const json = this.toJSON();
        let result = new VirtualImageInfo();
        result.init(json);
        return result;
    }
}

export interface IVirtualImageInfo {
    name: string;
    creationDate: Date;
}

export class VirtualImageSummary implements IVirtualImageSummary {
    id!: number;
    virtualImagePath!: string;
    virtualImageCreationDate!: Date;
    imageDescriptorsJson!: string;
    imageDescriptors!: PhotoTourDescriptor;

    constructor(data?: IVirtualImageSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.virtualImagePath = _data["VirtualImagePath"];
            this.virtualImageCreationDate = _data["VirtualImageCreationDate"] ? new Date(_data["VirtualImageCreationDate"].toString()) : <any>undefined;
            this.imageDescriptorsJson = _data["ImageDescriptorsJson"];
            this.imageDescriptors = _data["ImageDescriptors"] ? PhotoTourDescriptor.fromJS(_data["ImageDescriptors"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VirtualImageSummary {
        data = typeof data === 'object' ? data : {};
        let result = new VirtualImageSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["VirtualImagePath"] = this.virtualImagePath;
        data["VirtualImageCreationDate"] = this.virtualImageCreationDate ? this.virtualImageCreationDate.toISOString() : <any>undefined;
        data["ImageDescriptorsJson"] = this.imageDescriptorsJson;
        data["ImageDescriptors"] = this.imageDescriptors ? this.imageDescriptors.toJSON() : <any>undefined;
        return data;
    }

    clone(): VirtualImageSummary {
        const json = this.toJSON();
        let result = new VirtualImageSummary();
        result.init(json);
        return result;
    }
}

export interface IVirtualImageSummary {
    id: number;
    virtualImagePath: string;
    virtualImageCreationDate: Date;
    imageDescriptorsJson: string;
    imageDescriptors: PhotoTourDescriptor;
}

export class PhotoTourDescriptor implements IPhotoTourDescriptor {
    deviceTemperatures!: DeviceTemperature[];
    plantDescriptors!: PlantImageDescriptors[];
    tourName!: string;
    photoTourId!: number;
    photoTripId!: number;
    tripStart!: Date;
    tripEnd!: Date;

    constructor(data?: IPhotoTourDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DeviceTemperatures"])) {
                this.deviceTemperatures = [] as any;
                for (let item of _data["DeviceTemperatures"])
                    this.deviceTemperatures!.push(DeviceTemperature.fromJS(item));
            }
            if (Array.isArray(_data["PlantDescriptors"])) {
                this.plantDescriptors = [] as any;
                for (let item of _data["PlantDescriptors"])
                    this.plantDescriptors!.push(PlantImageDescriptors.fromJS(item));
            }
            this.tourName = _data["TourName"];
            this.photoTourId = _data["PhotoTourId"];
            this.photoTripId = _data["PhotoTripId"];
            this.tripStart = _data["TripStart"] ? new Date(_data["TripStart"].toString()) : <any>undefined;
            this.tripEnd = _data["TripEnd"] ? new Date(_data["TripEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotoTourDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceTemperatures)) {
            data["DeviceTemperatures"] = [];
            for (let item of this.deviceTemperatures)
                data["DeviceTemperatures"].push(item.toJSON());
        }
        if (Array.isArray(this.plantDescriptors)) {
            data["PlantDescriptors"] = [];
            for (let item of this.plantDescriptors)
                data["PlantDescriptors"].push(item.toJSON());
        }
        data["TourName"] = this.tourName;
        data["PhotoTourId"] = this.photoTourId;
        data["PhotoTripId"] = this.photoTripId;
        data["TripStart"] = this.tripStart ? this.tripStart.toISOString() : <any>undefined;
        data["TripEnd"] = this.tripEnd ? this.tripEnd.toISOString() : <any>undefined;
        return data;
    }

    clone(): PhotoTourDescriptor {
        const json = this.toJSON();
        let result = new PhotoTourDescriptor();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourDescriptor {
    deviceTemperatures: DeviceTemperature[];
    plantDescriptors: PlantImageDescriptors[];
    tourName: string;
    photoTourId: number;
    photoTripId: number;
    tripStart: Date;
    tripEnd: Date;
}

export class DeviceTemperature implements IDeviceTemperature {
    name!: string;
    averageTemperature!: number;
    medianTemperature!: number;
    maxTemperature!: number;
    minTemperature!: number;
    temperatureDeviation!: number;
    countOfMeasurements!: number;

    constructor(data?: IDeviceTemperature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.averageTemperature = _data["AverageTemperature"];
            this.medianTemperature = _data["MedianTemperature"];
            this.maxTemperature = _data["MaxTemperature"];
            this.minTemperature = _data["MinTemperature"];
            this.temperatureDeviation = _data["TemperatureDeviation"];
            this.countOfMeasurements = _data["CountOfMeasurements"];
        }
    }

    static fromJS(data: any): DeviceTemperature {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTemperature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["AverageTemperature"] = this.averageTemperature;
        data["MedianTemperature"] = this.medianTemperature;
        data["MaxTemperature"] = this.maxTemperature;
        data["MinTemperature"] = this.minTemperature;
        data["TemperatureDeviation"] = this.temperatureDeviation;
        data["CountOfMeasurements"] = this.countOfMeasurements;
        return data;
    }

    clone(): DeviceTemperature {
        const json = this.toJSON();
        let result = new DeviceTemperature();
        result.init(json);
        return result;
    }
}

export interface IDeviceTemperature {
    name: string;
    averageTemperature: number;
    medianTemperature: number;
    maxTemperature: number;
    minTemperature: number;
    temperatureDeviation: number;
    countOfMeasurements: number;
}

export class PlantImageDescriptors implements IPlantImageDescriptors {
    plant!: ReferencedPlant;
    sizeInMm2!: number;
    averageTemperature!: number;
    medianTemperature!: number;
    temperatureDev!: number;
    maxTemperature!: number;
    pixelCount!: number;
    minTemperature!: number;
    heightInMm!: number;
    widthInMm!: number;
    extent!: number;
    convexHullAreaInMm2!: number;
    solidity!: number;
    leafCount!: number;
    leafOutOfRange!: boolean;
    hslAverage!: number[];
    hslMedian!: number[];
    hslMax!: number[];
    hslMin!: number[];
    hslDeviation!: number[];
    noImage!: boolean;

    constructor(data?: IPlantImageDescriptors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plant = _data["Plant"] ? ReferencedPlant.fromJS(_data["Plant"]) : <any>undefined;
            this.sizeInMm2 = _data["SizeInMm2"];
            this.averageTemperature = _data["AverageTemperature"];
            this.medianTemperature = _data["MedianTemperature"];
            this.temperatureDev = _data["TemperatureDev"];
            this.maxTemperature = _data["MaxTemperature"];
            this.pixelCount = _data["PixelCount"];
            this.minTemperature = _data["MinTemperature"];
            this.heightInMm = _data["HeightInMm"];
            this.widthInMm = _data["WidthInMm"];
            this.extent = _data["Extent"];
            this.convexHullAreaInMm2 = _data["ConvexHullAreaInMm2"];
            this.solidity = _data["Solidity"];
            this.leafCount = _data["LeafCount"];
            this.leafOutOfRange = _data["LeafOutOfRange"];
            if (Array.isArray(_data["HslAverage"])) {
                this.hslAverage = [] as any;
                for (let item of _data["HslAverage"])
                    this.hslAverage!.push(item);
            }
            if (Array.isArray(_data["HslMedian"])) {
                this.hslMedian = [] as any;
                for (let item of _data["HslMedian"])
                    this.hslMedian!.push(item);
            }
            if (Array.isArray(_data["HslMax"])) {
                this.hslMax = [] as any;
                for (let item of _data["HslMax"])
                    this.hslMax!.push(item);
            }
            if (Array.isArray(_data["HslMin"])) {
                this.hslMin = [] as any;
                for (let item of _data["HslMin"])
                    this.hslMin!.push(item);
            }
            if (Array.isArray(_data["HslDeviation"])) {
                this.hslDeviation = [] as any;
                for (let item of _data["HslDeviation"])
                    this.hslDeviation!.push(item);
            }
            this.noImage = _data["NoImage"];
        }
    }

    static fromJS(data: any): PlantImageDescriptors {
        data = typeof data === 'object' ? data : {};
        let result = new PlantImageDescriptors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Plant"] = this.plant ? this.plant.toJSON() : <any>undefined;
        data["SizeInMm2"] = this.sizeInMm2;
        data["AverageTemperature"] = this.averageTemperature;
        data["MedianTemperature"] = this.medianTemperature;
        data["TemperatureDev"] = this.temperatureDev;
        data["MaxTemperature"] = this.maxTemperature;
        data["PixelCount"] = this.pixelCount;
        data["MinTemperature"] = this.minTemperature;
        data["HeightInMm"] = this.heightInMm;
        data["WidthInMm"] = this.widthInMm;
        data["Extent"] = this.extent;
        data["ConvexHullAreaInMm2"] = this.convexHullAreaInMm2;
        data["Solidity"] = this.solidity;
        data["LeafCount"] = this.leafCount;
        data["LeafOutOfRange"] = this.leafOutOfRange;
        if (Array.isArray(this.hslAverage)) {
            data["HslAverage"] = [];
            for (let item of this.hslAverage)
                data["HslAverage"].push(item);
        }
        if (Array.isArray(this.hslMedian)) {
            data["HslMedian"] = [];
            for (let item of this.hslMedian)
                data["HslMedian"].push(item);
        }
        if (Array.isArray(this.hslMax)) {
            data["HslMax"] = [];
            for (let item of this.hslMax)
                data["HslMax"].push(item);
        }
        if (Array.isArray(this.hslMin)) {
            data["HslMin"] = [];
            for (let item of this.hslMin)
                data["HslMin"].push(item);
        }
        if (Array.isArray(this.hslDeviation)) {
            data["HslDeviation"] = [];
            for (let item of this.hslDeviation)
                data["HslDeviation"].push(item);
        }
        data["NoImage"] = this.noImage;
        return data;
    }

    clone(): PlantImageDescriptors {
        const json = this.toJSON();
        let result = new PlantImageDescriptors();
        result.init(json);
        return result;
    }
}

export interface IPlantImageDescriptors {
    plant: ReferencedPlant;
    sizeInMm2: number;
    averageTemperature: number;
    medianTemperature: number;
    temperatureDev: number;
    maxTemperature: number;
    pixelCount: number;
    minTemperature: number;
    heightInMm: number;
    widthInMm: number;
    extent: number;
    convexHullAreaInMm2: number;
    solidity: number;
    leafCount: number;
    leafOutOfRange: boolean;
    hslAverage: number[];
    hslMedian: number[];
    hslMax: number[];
    hslMin: number[];
    hslDeviation: number[];
    noImage: boolean;
}

export class ReferencedPlant implements IReferencedPlant {
    imageIndex!: number;
    motorPosition!: number;
    imageName!: string;
    imageComment!: string;
    hasIr!: boolean;
    hasVis!: boolean;
    irTime!: Date;
    visTime!: Date;
    irTempInC!: number;

    constructor(data?: IReferencedPlant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageIndex = _data["ImageIndex"];
            this.motorPosition = _data["MotorPosition"];
            this.imageName = _data["ImageName"];
            this.imageComment = _data["ImageComment"];
            this.hasIr = _data["HasIr"];
            this.hasVis = _data["HasVis"];
            this.irTime = _data["IrTime"] ? new Date(_data["IrTime"].toString()) : <any>undefined;
            this.visTime = _data["VisTime"] ? new Date(_data["VisTime"].toString()) : <any>undefined;
            this.irTempInC = _data["IrTempInC"];
        }
    }

    static fromJS(data: any): ReferencedPlant {
        data = typeof data === 'object' ? data : {};
        let result = new ReferencedPlant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ImageIndex"] = this.imageIndex;
        data["MotorPosition"] = this.motorPosition;
        data["ImageName"] = this.imageName;
        data["ImageComment"] = this.imageComment;
        data["HasIr"] = this.hasIr;
        data["HasVis"] = this.hasVis;
        data["IrTime"] = this.irTime ? this.irTime.toISOString() : <any>undefined;
        data["VisTime"] = this.visTime ? this.visTime.toISOString() : <any>undefined;
        data["IrTempInC"] = this.irTempInC;
        return data;
    }

    clone(): ReferencedPlant {
        const json = this.toJSON();
        let result = new ReferencedPlant();
        result.init(json);
        return result;
    }
}

export interface IReferencedPlant {
    imageIndex: number;
    motorPosition: number;
    imageName: string;
    imageComment: string;
    hasIr: boolean;
    hasVis: boolean;
    irTime: Date;
    visTime: Date;
    irTempInC: number;
}

export class TemperatureSummaryData implements ITemperatureSummaryData {
    device!: string;
    data!: TemperatureDatum[];

    constructor(data?: ITemperatureSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.device = _data["Device"];
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(TemperatureDatum.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemperatureSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Device"] = this.device;
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }

    clone(): TemperatureSummaryData {
        const json = this.toJSON();
        let result = new TemperatureSummaryData();
        result.init(json);
        return result;
    }
}

export interface ITemperatureSummaryData {
    device: string;
    data: TemperatureDatum[];
}

export class TemperatureDatum implements ITemperatureDatum {
    time!: Date;
    temperature!: number;
    deviation!: number;

    constructor(data?: ITemperatureDatum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["Time"] ? new Date(_data["Time"].toString()) : <any>undefined;
            this.temperature = _data["Temperature"];
            this.deviation = _data["Deviation"];
        }
    }

    static fromJS(data: any): TemperatureDatum {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureDatum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["Temperature"] = this.temperature;
        data["Deviation"] = this.deviation;
        return data;
    }

    clone(): TemperatureDatum {
        const json = this.toJSON();
        let result = new TemperatureDatum();
        result.init(json);
        return result;
    }
}

export interface ITemperatureDatum {
    time: Date;
    temperature: number;
    deviation: number;
}

export class DownloadInfo implements IDownloadInfo {
    photoTourId!: number;
    path!: string;
    currentSize!: number;
    sizeToDownloadInGb!: number;
    readyToDownload!: boolean;

    constructor(data?: IDownloadInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photoTourId = _data["PhotoTourId"];
            this.path = _data["Path"];
            this.currentSize = _data["CurrentSize"];
            this.sizeToDownloadInGb = _data["SizeToDownloadInGb"];
            this.readyToDownload = _data["ReadyToDownload"];
        }
    }

    static fromJS(data: any): DownloadInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhotoTourId"] = this.photoTourId;
        data["Path"] = this.path;
        data["CurrentSize"] = this.currentSize;
        data["SizeToDownloadInGb"] = this.sizeToDownloadInGb;
        data["ReadyToDownload"] = this.readyToDownload;
        return data;
    }

    clone(): DownloadInfo {
        const json = this.toJSON();
        let result = new DownloadInfo();
        result.init(json);
        return result;
    }
}

export interface IDownloadInfo {
    photoTourId: number;
    path: string;
    currentSize: number;
    sizeToDownloadInGb: number;
    readyToDownload: boolean;
}

export class UploadProgress implements IUploadProgress {
    status!: string;
    extractedImages!: number;
    createdTrips!: number;

    constructor(data?: IUploadProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["Status"];
            this.extractedImages = _data["ExtractedImages"];
            this.createdTrips = _data["CreatedTrips"];
        }
    }

    static fromJS(data: any): UploadProgress {
        data = typeof data === 'object' ? data : {};
        let result = new UploadProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Status"] = this.status;
        data["ExtractedImages"] = this.extractedImages;
        data["CreatedTrips"] = this.createdTrips;
        return data;
    }

    clone(): UploadProgress {
        const json = this.toJSON();
        let result = new UploadProgress();
        result.init(json);
        return result;
    }
}

export interface IUploadProgress {
    status: string;
    extractedImages: number;
    createdTrips: number;
}

export class PhotoTourInfo implements IPhotoTourInfo {
    name!: string;
    finished!: boolean;
    id!: number;
    firstEvent!: Date;
    lastEvent!: Date;
    intervallInMinutes!: number;
    comment!: string;
    pixelSizeInMm!: number;
    tripCount!: number;

    constructor(data?: IPhotoTourInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.finished = _data["Finished"];
            this.id = _data["Id"];
            this.firstEvent = _data["FirstEvent"] ? new Date(_data["FirstEvent"].toString()) : <any>undefined;
            this.lastEvent = _data["LastEvent"] ? new Date(_data["LastEvent"].toString()) : <any>undefined;
            this.intervallInMinutes = _data["IntervallInMinutes"];
            this.comment = _data["Comment"];
            this.pixelSizeInMm = _data["PixelSizeInMm"];
            this.tripCount = _data["TripCount"];
        }
    }

    static fromJS(data: any): PhotoTourInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoTourInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Finished"] = this.finished;
        data["Id"] = this.id;
        data["FirstEvent"] = this.firstEvent ? this.firstEvent.toISOString() : <any>undefined;
        data["LastEvent"] = this.lastEvent ? this.lastEvent.toISOString() : <any>undefined;
        data["IntervallInMinutes"] = this.intervallInMinutes;
        data["Comment"] = this.comment;
        data["PixelSizeInMm"] = this.pixelSizeInMm;
        data["TripCount"] = this.tripCount;
        return data;
    }

    clone(): PhotoTourInfo {
        const json = this.toJSON();
        let result = new PhotoTourInfo();
        result.init(json);
        return result;
    }
}

export interface IPhotoTourInfo {
    name: string;
    finished: boolean;
    id: number;
    firstEvent: Date;
    lastEvent: Date;
    intervallInMinutes: number;
    comment: string;
    pixelSizeInMm: number;
    tripCount: number;
}

export class AutomaticTourStartInfo implements IAutomaticTourStartInfo {
    intervallInMinutes!: number;
    movementPlan!: number;
    temperatureMeasureDevice!: TemperatureMeasurementInfo[];
    comment!: string;
    name!: string;
    deviceGuid!: string;
    shouldUseIR!: boolean;
    pixelSizeInMm!: number;

    constructor(data?: IAutomaticTourStartInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.intervallInMinutes = _data["IntervallInMinutes"];
            this.movementPlan = _data["MovementPlan"];
            if (Array.isArray(_data["TemperatureMeasureDevice"])) {
                this.temperatureMeasureDevice = [] as any;
                for (let item of _data["TemperatureMeasureDevice"])
                    this.temperatureMeasureDevice!.push(TemperatureMeasurementInfo.fromJS(item));
            }
            this.comment = _data["Comment"];
            this.name = _data["Name"];
            this.deviceGuid = _data["DeviceGuid"];
            this.shouldUseIR = _data["ShouldUseIR"];
            this.pixelSizeInMm = _data["PixelSizeInMm"];
        }
    }

    static fromJS(data: any): AutomaticTourStartInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticTourStartInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IntervallInMinutes"] = this.intervallInMinutes;
        data["MovementPlan"] = this.movementPlan;
        if (Array.isArray(this.temperatureMeasureDevice)) {
            data["TemperatureMeasureDevice"] = [];
            for (let item of this.temperatureMeasureDevice)
                data["TemperatureMeasureDevice"].push(item.toJSON());
        }
        data["Comment"] = this.comment;
        data["Name"] = this.name;
        data["DeviceGuid"] = this.deviceGuid;
        data["ShouldUseIR"] = this.shouldUseIR;
        data["PixelSizeInMm"] = this.pixelSizeInMm;
        return data;
    }

    clone(): AutomaticTourStartInfo {
        const json = this.toJSON();
        let result = new AutomaticTourStartInfo();
        result.init(json);
        return result;
    }
}

export interface IAutomaticTourStartInfo {
    intervallInMinutes: number;
    movementPlan: number;
    temperatureMeasureDevice: TemperatureMeasurementInfo[];
    comment: string;
    name: string;
    deviceGuid: string;
    shouldUseIR: boolean;
    pixelSizeInMm: number;
}

export class TemperatureMeasurementInfo implements ITemperatureMeasurementInfo {
    guid!: string;
    comment!: string;

    constructor(data?: ITemperatureMeasurementInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["Guid"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): TemperatureMeasurementInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureMeasurementInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["Comment"] = this.comment;
        return data;
    }

    clone(): TemperatureMeasurementInfo {
        const json = this.toJSON();
        let result = new TemperatureMeasurementInfo();
        result.init(json);
        return result;
    }
}

export interface ITemperatureMeasurementInfo {
    guid: string;
    comment: string;
}

export class StreamingMetaData implements IStreamingMetaData {
    resolutionDivider!: number;
    quality!: number;
    distanceInM!: number;
    storeData!: boolean;
    positionsToStream!: number[];
    type!: string;

    constructor(data?: IStreamingMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resolutionDivider = _data["ResolutionDivider"];
            this.quality = _data["Quality"];
            this.distanceInM = _data["DistanceInM"];
            this.storeData = _data["StoreData"];
            if (Array.isArray(_data["PositionsToStream"])) {
                this.positionsToStream = [] as any;
                for (let item of _data["PositionsToStream"])
                    this.positionsToStream!.push(item);
            }
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): StreamingMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new StreamingMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResolutionDivider"] = this.resolutionDivider;
        data["Quality"] = this.quality;
        data["DistanceInM"] = this.distanceInM;
        data["StoreData"] = this.storeData;
        if (Array.isArray(this.positionsToStream)) {
            data["PositionsToStream"] = [];
            for (let item of this.positionsToStream)
                data["PositionsToStream"].push(item);
        }
        data["Type"] = this.type;
        return data;
    }

    clone(): StreamingMetaData {
        const json = this.toJSON();
        let result = new StreamingMetaData();
        result.init(json);
        return result;
    }
}

export interface IStreamingMetaData {
    resolutionDivider: number;
    quality: number;
    distanceInM: number;
    storeData: boolean;
    positionsToStream: number[];
    type: string;
}

export class TemperatureStreamData implements ITemperatureStreamData {
    temperatureInC!: number;
    device!: string;
    time!: Date;

    constructor(data?: ITemperatureStreamData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperatureInC = _data["TemperatureInC"];
            this.device = _data["Device"];
            this.time = _data["Time"] ? new Date(_data["Time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TemperatureStreamData {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureStreamData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TemperatureInC"] = this.temperatureInC;
        data["Device"] = this.device;
        data["Time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }

    clone(): TemperatureStreamData {
        const json = this.toJSON();
        let result = new TemperatureStreamData();
        result.init(json);
        return result;
    }
}

export interface ITemperatureStreamData {
    temperatureInC: number;
    device: string;
    time: Date;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable @typescript-eslint/no-unused-vars */